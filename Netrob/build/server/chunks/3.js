require("source-map-support").install();
exports.ids = [3];
exports.modules = {

/***/ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./src/routes/webrtc/WebRTC.scss":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, "/**\n * React Starter Kit (https://www.reactstarterkit.com/)\n *\n * Copyright © 2014-present Kriasoft, LLC. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\n/**\n * React Starter Kit (https://www.reactstarterkit.com/)\n *\n * Copyright © 2014-present Kriasoft, LLC. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\n:root {\n  /*\n   * Typography\n   * ======================================================================== */\n\n  --font-family-base: 'Segoe UI', 'HelveticaNeue-Light', sans-serif;\n\n  /*\n   * Layout\n   * ======================================================================== */\n\n  --max-content-width: 1000px;\n\n  /*\n   * Application specific\n   * ======================================================================== */\n\n  --hedgehog-green-light: #38b449;\n  --hedgehog-green-dark: #007c3c;\n\n  /*\n   * Media queries breakpoints\n   * ======================================================================== */\n\n  --screen-xs-min: 480px;  /* Extra small screen / phone */\n  --screen-sm-min: 768px;  /* Small screen / tablet */\n  --screen-md-min: 992px;  /* Medium screen / desktop */\n  --screen-lg-min: 1200px; /* Large screen / wide desktop */\n}\n\n.WebRTC-root-1QkH8 {\n  padding-left: 20px;\n  padding-right: 20px;\n}\n\n.WebRTC-container-1NFMP {\n  margin: 0 auto;\n  padding: 0 0 40px;\n  max-width: 1000px;\n  max-width: var(--max-content-width);\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-flow: row nowrap;\n      flex-flow: row nowrap;\n}\n\n.WebRTC-chat-tV1Ck {\n  -ms-flex: 1 0;\n      flex: 1 0;\n  margin: 10px;\n  padding: 0 5px 5px\n}\n\n.WebRTC-chat-tV1Ck .WebRTC-msg-3CO_I {\n    margin: 5px 0;\n    padding: 5px\n  }\n\n.WebRTC-chat-tV1Ck .WebRTC-msg-3CO_I.WebRTC-mine-1myil {\n      margin-left: 4cm;\n      background-color: #ddd;\n    }\n\n.WebRTC-chat-tV1Ck .WebRTC-msg-3CO_I.WebRTC-theirs-3XZtd {\n      margin-right: 4cm;\n      background-color: #95f;\n      color: white;\n    }\n\n.WebRTC-editor-18FpN {\n  -ms-flex: 1 0;\n      flex: 1 0;\n  margin: 10px;\n  padding: 5px\n}\n\n.WebRTC-editor-18FpN .WebRTC-editor-wrapper-5fCiA {\n    position: relative;\n    height: 300px;\n  }\n\n.WebRTC-remote-cursor-1_CSr {\n  position: absolute;\n  z-index: 4;\n  border-radius: 0;\n  border-left: 2px solid #cc0000;\n}\n\n.WebRTC-remote-selection-1JjzY {\n  position: absolute;\n  background-color: #ff7788;\n  z-index: 3;\n}\n", "", {"version":3,"sources":["/home/sarah/Documents/Arbeit/github/netRob/Netrob/src/routes/webrtc/WebRTC.scss"],"names":[],"mappings":"AAAA;;;;;;;GAOG;;AAEH;;;;;;;GAOG;;AAEH;EACE;;gFAE8E;;EAE9E,kEAAkE;;EAElE;;gFAE8E;;EAE9E,4BAA4B;;EAE5B;;gFAE8E;;EAE9E,gCAAgC;EAChC,+BAA+B;;EAE/B;;gFAE8E;;EAE9E,uBAAuB,EAAE,gCAAgC;EACzD,uBAAuB,EAAE,2BAA2B;EACpD,uBAAuB,EAAE,6BAA6B;EACtD,wBAAwB,CAAC,iCAAiC;CAC3D;;AAED;EACE,mBAAmB;EACnB,oBAAoB;CACrB;;AAED;EACE,eAAe;EACf,kBAAkB;EAClB,kBAAkB;EAClB,oCAAoC;EACpC,qBAAqB;EACrB,cAAc;EACd,0BAA0B;MACtB,sBAAsB;CAC3B;;AAED;EACE,cAAc;MACV,UAAU;EACd,aAAa;EACb,kBAAkB;CACnB;;AAED;IACI,cAAc;IACd,YAAY;GACb;;AAEH;MACM,iBAAiB;MACjB,uBAAuB;KACxB;;AAEL;MACM,kBAAkB;MAClB,uBAAuB;MACvB,aAAa;KACd;;AAEL;EACE,cAAc;MACV,UAAU;EACd,aAAa;EACb,YAAY;CACb;;AAED;IACI,mBAAmB;IACnB,cAAc;GACf;;AAEH;EACE,mBAAmB;EACnB,WAAW;EACX,iBAAiB;EACjB,+BAA+B;CAChC;;AAED;EACE,mBAAmB;EACnB,0BAA0B;EAC1B,WAAW;CACZ","file":"WebRTC.scss","sourcesContent":["/**\n * React Starter Kit (https://www.reactstarterkit.com/)\n *\n * Copyright © 2014-present Kriasoft, LLC. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\n/**\n * React Starter Kit (https://www.reactstarterkit.com/)\n *\n * Copyright © 2014-present Kriasoft, LLC. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\n:root {\n  /*\n   * Typography\n   * ======================================================================== */\n\n  --font-family-base: 'Segoe UI', 'HelveticaNeue-Light', sans-serif;\n\n  /*\n   * Layout\n   * ======================================================================== */\n\n  --max-content-width: 1000px;\n\n  /*\n   * Application specific\n   * ======================================================================== */\n\n  --hedgehog-green-light: #38b449;\n  --hedgehog-green-dark: #007c3c;\n\n  /*\n   * Media queries breakpoints\n   * ======================================================================== */\n\n  --screen-xs-min: 480px;  /* Extra small screen / phone */\n  --screen-sm-min: 768px;  /* Small screen / tablet */\n  --screen-md-min: 992px;  /* Medium screen / desktop */\n  --screen-lg-min: 1200px; /* Large screen / wide desktop */\n}\n\n.root {\n  padding-left: 20px;\n  padding-right: 20px;\n}\n\n.container {\n  margin: 0 auto;\n  padding: 0 0 40px;\n  max-width: 1000px;\n  max-width: var(--max-content-width);\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-flow: row nowrap;\n      flex-flow: row nowrap;\n}\n\n.chat {\n  -ms-flex: 1 0;\n      flex: 1 0;\n  margin: 10px;\n  padding: 0 5px 5px\n}\n\n.chat .msg {\n    margin: 5px 0;\n    padding: 5px\n  }\n\n.chat .msg.mine {\n      margin-left: 4cm;\n      background-color: #ddd;\n    }\n\n.chat .msg.theirs {\n      margin-right: 4cm;\n      background-color: #95f;\n      color: white;\n    }\n\n.editor {\n  -ms-flex: 1 0;\n      flex: 1 0;\n  margin: 10px;\n  padding: 5px\n}\n\n.editor .editor-wrapper {\n    position: relative;\n    height: 300px;\n  }\n\n.remote-cursor {\n  position: absolute;\n  z-index: 4;\n  border-radius: 0;\n  border-left: 2px solid #cc0000;\n}\n\n.remote-selection {\n  position: absolute;\n  background-color: #ff7788;\n  z-index: 3;\n}\n"],"sourceRoot":""}]);

// exports
exports.locals = {
	"root": "WebRTC-root-1QkH8",
	"container": "WebRTC-container-1NFMP",
	"chat": "WebRTC-chat-tV1Ck",
	"msg": "WebRTC-msg-3CO_I",
	"mine": "WebRTC-mine-1myil",
	"theirs": "WebRTC-theirs-3XZtd",
	"editor": "WebRTC-editor-18FpN",
	"editor-wrapper": "WebRTC-editor-wrapper-5fCiA",
	"remote-cursor": "WebRTC-remote-cursor-1_CSr",
	"remote-selection": "WebRTC-remote-selection-1JjzY"
};

/***/ }),

/***/ "./src/routes/webrtc/AcePeerEditor.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_ace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("react-ace");
/* harmony import */ var react_ace__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_ace__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _useConclave__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/routes/webrtc/useConclave.js");
/* harmony import */ var _WebRTC_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/routes/webrtc/WebRTC.scss");
/* harmony import */ var _WebRTC_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_WebRTC_scss__WEBPACK_IMPORTED_MODULE_3__);
var _jsxFileName = "/home/sarah/Documents/Arbeit/github/netRob/Netrob/src/routes/webrtc/AcePeerEditor.js";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }



 // eslint-disable-next-line css-modules/no-unused-class


const AcePeerEditor = react__WEBPACK_IMPORTED_MODULE_0__["forwardRef"](({
  connectionConfig,
  ...props
}, ref) => {
  function getMarkerClassName(_siteId, type) {
    return _WebRTC_scss__WEBPACK_IMPORTED_MODULE_3___default.a[`remote-${type}`];
  }

  const conclave = Object(_useConclave__WEBPACK_IMPORTED_MODULE_2__["default"])(connectionConfig, getMarkerClassName);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_ace__WEBPACK_IMPORTED_MODULE_1___default.a, _extends({
    ref: ref
  }, conclave.mountAceEditor(props), {
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 29,
      columnNumber: 12
    }
  }));
});
/* harmony default export */ __webpack_exports__["default"] = (AcePeerEditor);

/***/ }),

/***/ "./src/routes/webrtc/WebRTC.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var isomorphic_style_loader_useStyles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("isomorphic-style-loader/useStyles");
/* harmony import */ var isomorphic_style_loader_useStyles__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(isomorphic_style_loader_useStyles__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("@material-ui/core/Paper");
/* harmony import */ var _material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var peerjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("peerjs");
/* harmony import */ var peerjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(peerjs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_ace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("react-ace");
/* harmony import */ var react_ace__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_ace__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ace_builds_webpack_resolver__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("ace-builds/webpack-resolver");
/* harmony import */ var ace_builds_webpack_resolver__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ace_builds_webpack_resolver__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ace_builds_src_noconflict_mode_javascript__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("ace-builds/src-noconflict/mode-javascript");
/* harmony import */ var ace_builds_src_noconflict_mode_javascript__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ace_builds_src_noconflict_mode_javascript__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ace_builds_src_noconflict_ext_language_tools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("ace-builds/src-noconflict/ext-language_tools");
/* harmony import */ var ace_builds_src_noconflict_ext_language_tools__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ace_builds_src_noconflict_ext_language_tools__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ace_builds_src_noconflict_theme_github__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("ace-builds/src-noconflict/theme-github");
/* harmony import */ var ace_builds_src_noconflict_theme_github__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ace_builds_src_noconflict_theme_github__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _AcePeerEditor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/routes/webrtc/AcePeerEditor.js");
/* harmony import */ var _WebRTC_scss__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/routes/webrtc/WebRTC.scss");
/* harmony import */ var _WebRTC_scss__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_WebRTC_scss__WEBPACK_IMPORTED_MODULE_10__);
var _jsxFileName = "/home/sarah/Documents/Arbeit/github/netRob/Netrob/src/routes/webrtc/WebRTC.js";









 // eslint-disable-next-line css-modules/no-unused-class


const peerOptions =  true ? {
  host: 'localhost',
  port: 3010,
  path: '/peerjs'
} : undefined;

function msg(type, text) {
  return {
    type,
    text
  };
}

function Chat({
  connection,
  sendText
}) {
  const [messages, setMessages] = react__WEBPACK_IMPORTED_MODULE_0__["useState"]([]);

  function handleSend() {
    if (connection === null) return;
    setMessages(oldMessages => [...oldMessages, msg('OUT', sendText)]);
    connection.send(sendText);
  }

  react__WEBPACK_IMPORTED_MODULE_0__["useEffect"](() => {
    if (connection === null) return undefined;

    function handleRecv(text) {
      setMessages(oldMessages => [...oldMessages, msg('IN', text)]);
    }

    connection.on('data', handleRecv);
    return () => {
      connection.off('data', handleRecv);
    };
  }, [connection]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_2___default.a, {
    className: _WebRTC_scss__WEBPACK_IMPORTED_MODULE_10___default.a.chat,
    square: true,
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 71,
      columnNumber: 5
    }
  }, messages.map(({
    type,
    text
  }, index) =>
  /*#__PURE__*/
  // eslint-disable-next-line react/no-array-index-key
  react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", {
    key: index,
    className: `${_WebRTC_scss__WEBPACK_IMPORTED_MODULE_10___default.a.msg} ${type === 'OUT' ? _WebRTC_scss__WEBPACK_IMPORTED_MODULE_10___default.a.mine : _WebRTC_scss__WEBPACK_IMPORTED_MODULE_10___default.a.theirs}`,
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 74,
      columnNumber: 9
    }
  }, text)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 78,
      columnNumber: 7
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("button", {
    type: "button",
    onClick: handleSend,
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 79,
      columnNumber: 9
    }
  }, "Send"), "Connected: ", connection !== null ? 'yes' : 'no'));
}

function Editor({
  connectionConfig
}) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_material_ui_core_Paper__WEBPACK_IMPORTED_MODULE_2___default.a, {
    className: _WebRTC_scss__WEBPACK_IMPORTED_MODULE_10___default.a.editor,
    square: true,
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 94,
      columnNumber: 5
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", {
    className: _WebRTC_scss__WEBPACK_IMPORTED_MODULE_10___default.a['editor-wrapper'],
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 95,
      columnNumber: 7
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_AcePeerEditor__WEBPACK_IMPORTED_MODULE_9__["default"], {
    connectionConfig: {
      peerOptions,
      ...connectionConfig
    },
    mode: "javascript",
    theme: "github",
    name: "editor",
    width: "100%",
    height: "100%",
    fontSize: 16,
    showGutter: true,
    highlightActiveLine: true,
    autoScrollEditorIntoView: true,
    style: {
      position: 'absolute'
    },
    setOptions: {
      enableBasicAutocompletion: true,
      enableLiveAutocompletion: true,
      // enableSnippets: enableSnippets,
      showLineNumbers: true,
      tabSize: 2
    },
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 96,
      columnNumber: 9
    }
  })));
}

function WebRTC(_props) {
  const [left, setLeft] = react__WEBPACK_IMPORTED_MODULE_0__["useState"](null);
  const [right, setRight] = react__WEBPACK_IMPORTED_MODULE_0__["useState"](null);
  react__WEBPACK_IMPORTED_MODULE_0__["useEffect"](() => {
    (async () => {
      // eslint-disable-next-line no-console
      console.log('options:', peerOptions);
      const leftPeer = new peerjs__WEBPACK_IMPORTED_MODULE_3___default.a(peerOptions);
      const rightPeer = new peerjs__WEBPACK_IMPORTED_MODULE_3___default.a(peerOptions); // eslint-disable-next-line no-console

      console.log('peers created'); // eslint-disable-next-line no-console

      leftPeer.on('error', err => console.log(err)); // eslint-disable-next-line no-console

      rightPeer.on('error', err => console.log(err));
      const leftId = await new Promise(resolve => leftPeer.on('open', resolve));
      const rightId = await new Promise(resolve => rightPeer.on('open', resolve)); // eslint-disable-next-line no-console

      console.log(leftId, rightId);
      const rightConn = rightPeer.connect(leftId);
      const leftConn = await new Promise(resolve => leftPeer.on('connection', resolve)); // eslint-disable-next-line no-console

      console.log('peers connected');
      setLeft(leftConn);
      setRight(rightConn);
    })();
  }, []);
  isomorphic_style_loader_useStyles__WEBPACK_IMPORTED_MODULE_1___default()(_WebRTC_scss__WEBPACK_IMPORTED_MODULE_10___default.a);
  const [leftPeerId, setLeftPeerId] = react__WEBPACK_IMPORTED_MODULE_0__["useState"](null);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", {
    className: _WebRTC_scss__WEBPACK_IMPORTED_MODULE_10___default.a.root,
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 161,
      columnNumber: 5
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", {
    className: _WebRTC_scss__WEBPACK_IMPORTED_MODULE_10___default.a.container,
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 162,
      columnNumber: 7
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Chat, {
    connection: left,
    sendText: "Hello",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 163,
      columnNumber: 9
    }
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Chat, {
    connection: right,
    sendText: "There",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 164,
      columnNumber: 9
    }
  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", {
    className: _WebRTC_scss__WEBPACK_IMPORTED_MODULE_10___default.a.container,
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 166,
      columnNumber: 7
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Editor, {
    connectionConfig: {
      siteId: 'left',
      targetPeerId: null,
      onOpen: setLeftPeerId
    },
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 167,
      columnNumber: 9
    }
  }), leftPeerId && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Editor, {
    connectionConfig: {
      siteId: 'right',
      targetPeerId: leftPeerId
    },
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 175,
      columnNumber: 11
    }
  })));
}

/* harmony default export */ __webpack_exports__["default"] = (WebRTC);

/***/ }),

/***/ "./src/routes/webrtc/WebRTC.scss":
/***/ (function(module, exports, __webpack_require__) {


    var refs = 0;
    var css = __webpack_require__("./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./src/routes/webrtc/WebRTC.scss");
    var insertCss = __webpack_require__("./node_modules/isomorphic-style-loader/insertCss.js");
    var content = typeof css === 'string' ? [[module.i, css, '']] : css;

    exports = module.exports = css.locals || {};
    exports._getContent = function() { return content; };
    exports._getCss = function() { return '' + css; };
    exports._insertCss = function(options) { return insertCss(content, options) };

    // Hot Module Replacement
    // https://webpack.github.io/docs/hot-module-replacement
    // Only activated in browser context
    if ( true && typeof window !== 'undefined' && window.document) {
      var removeCss = function() {};
      module.hot.accept("./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./src/routes/webrtc/WebRTC.scss", function() {
        css = __webpack_require__("./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./src/routes/webrtc/WebRTC.scss");
        content = typeof css === 'string' ? [[module.i, css, '']] : css;
        removeCss = insertCss(content, { replace: true });
      });
      module.hot.dispose(function() { removeCss(); });
    }
  

/***/ }),

/***/ "./src/routes/webrtc/conclave/broadcast.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var peerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("peerjs");
/* harmony import */ var peerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(peerjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/routes/webrtc/conclave/controller.js");
/* harmony import */ var _char__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/routes/webrtc/conclave/char.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





class Broadcast {
  constructor(controller, peer, targetPeerId) {
    _defineProperty(this, "controller", void 0);

    _defineProperty(this, "peer", void 0);

    _defineProperty(this, "outConns", void 0);

    _defineProperty(this, "inConns", void 0);

    _defineProperty(this, "outgoingBuffer", void 0);

    _defineProperty(this, "MAX_BUFFER_SIZE", void 0);

    _defineProperty(this, "heartbeat", void 0);

    this.controller = controller;
    this.peer = peer;
    this.outConns = [];
    this.inConns = [];
    this.outgoingBuffer = [];
    this.MAX_BUFFER_SIZE = 40;
    this.heartbeat = this.startPeerHeartBeat(peer);
    this.onOpen(targetPeerId);
  }

  send(operation) {
    const operationJSON = JSON.stringify(operation);

    if (operation.type === 'insert' || operation.type === 'delete') {
      this.addToOutgoingBuffer(operationJSON);
    }

    this.outConns.forEach(conn => conn.send(operationJSON));
  }

  addToOutgoingBuffer(operationJSON) {
    if (this.outgoingBuffer.length === this.MAX_BUFFER_SIZE) {
      this.outgoingBuffer.shift();
    }

    this.outgoingBuffer.push(operationJSON);
  }

  processOutgoingBuffer(peerId) {
    const connection = this.outConns.find(conn => conn.peer === peerId);
    this.outgoingBuffer.forEach(op => {
      connection.send(op);
    });
  }

  startPeerHeartBeat(peer) {
    let timeoutId = null;

    const heartbeat = () => {
      timeoutId = setTimeout(heartbeat, 20000);

      if (peer.socket._wsOpen()) {
        peer.socket.send({
          type: 'HEARTBEAT'
        });
      }
    };

    heartbeat();
    return {
      start() {
        if (timeoutId === null) {
          heartbeat();
        }
      },

      stop() {
        clearTimeout(timeoutId);
        timeoutId = null;
      }

    };
  }

  onOpen(targetPeerId) {
    this.peer.on('open', id => {
      this.onPeerConnection();
      this.onError();
      this.onDisconnect();

      if (targetPeerId === null) {
        this.controller.addToNetwork(id, this.controller.siteId);
      } else {
        this.requestConnection(targetPeerId, id, this.controller.siteId);
      }
    });
  }

  onError() {
    this.peer.on('error', err => {
      const pid = String(err).replace('Error: Could not connect to peer ', '');
      this.removeFromConnections(pid);
      console.log(err.type);

      if (!this.peer.disconnected) {
        this.controller.findNewTarget();
      }
    });
  }

  onDisconnect() {
    this.peer.on('disconnected', () => {
      this.controller.lostConnection();
    });
  }

  requestConnection(target, peerId, siteId) {
    const conn = this.peer.connect(target);
    this.addToOutConns(conn);
    conn.on('open', () => {
      conn.send(JSON.stringify({
        type: 'connRequest',
        peerId,
        siteId
      }));
    });
  }

  evaluateRequest(peerId, siteId) {
    if (this.hasReachedMax()) {
      this.forwardConnRequest(peerId, siteId);
    } else {
      this.acceptConnRequest(peerId, siteId);
    }
  }

  hasReachedMax() {
    const halfTheNetwork = Math.ceil(this.controller.network.length / 2);
    const tooManyInConns = this.inConns.length > Math.max(halfTheNetwork, 5);
    const tooManyOutConns = this.outConns.length > Math.max(halfTheNetwork, 5);
    return tooManyInConns || tooManyOutConns;
  }

  forwardConnRequest(peerId, siteId) {
    const connected = this.outConns.filter(conn => conn.peer !== peerId);
    const randomIdx = Math.floor(Math.random() * connected.length);
    connected[randomIdx].send(JSON.stringify({
      type: 'connRequest',
      peerId,
      siteId
    }));
  }

  addToOutConns(connection) {
    if (!!connection && !this.isAlreadyConnectedOut(connection)) {
      this.outConns.push(connection);
    }
  }

  addToInConns(connection) {
    if (!!connection && !this.isAlreadyConnectedIn(connection)) {
      this.inConns.push(connection);
    }
  }

  addToNetwork(peerId, siteId) {
    this.send({
      type: 'add to network',
      newPeer: peerId,
      newSite: siteId
    });
  }

  removeFromNetwork(peerId) {
    this.send({
      type: 'remove from network',
      oldPeer: peerId
    });
    this.controller.removeFromNetwork(peerId);
  }

  removeFromConnections(peer) {
    this.inConns = this.inConns.filter(conn => conn.peer !== peer);
    this.outConns = this.outConns.filter(conn => conn.peer !== peer);
    this.removeFromNetwork(peer);
  }

  isAlreadyConnectedOut(connection) {
    if (connection.peer) {
      return !!this.outConns.find(conn => conn.peer === connection.peer);
    } else {
      return !!this.outConns.find(conn => conn.peer.id === connection);
    }
  }

  isAlreadyConnectedIn(connection) {
    if (connection.peer) {
      return !!this.inConns.find(conn => conn.peer === connection.peer);
    } else {
      return !!this.inConns.find(conn => conn.peer.id === connection);
    }
  }

  onPeerConnection() {
    this.peer.on('connection', connection => {
      this.onConnection(connection);
      this.onData(connection);
      this.onConnClose(connection);
    });
  }

  acceptConnRequest(peerId, siteId) {
    const connBack = this.peer.connect(peerId);
    this.addToOutConns(connBack);
    this.controller.addToNetwork(peerId, siteId);
    const initialData = JSON.stringify({
      type: 'syncResponse',
      siteId: this.controller.siteId,
      peerId: this.peer.id,
      initialStruct: this.controller.crdt.struct,
      initialVersions: this.controller.vector.versions,
      network: this.controller.network
    });

    if (connBack.open) {
      connBack.send(initialData);
    } else {
      connBack.on('open', () => {
        connBack.send(initialData);
      });
    }
  }

  onConnection(connection) {
    this.addToInConns(connection);
  }

  onData(connection) {
    connection.on('data', data => {
      const dataObj = JSON.parse(data);

      switch (dataObj.type) {
        case 'connRequest':
          this.evaluateRequest(dataObj.peerId, dataObj.siteId);
          break;

        case 'syncResponse':
          this.processOutgoingBuffer(dataObj.peerId);
          this.controller.handleSync(dataObj);
          break;

        case 'syncCompleted':
          this.processOutgoingBuffer(dataObj.peerId);
          break;

        case 'add to network':
          this.controller.addToNetwork(dataObj.newPeer, dataObj.newSite);
          break;

        case 'remove from network':
          this.controller.removeFromNetwork(dataObj.oldPeer);
          break;

        default:
          this.controller.handleRemoteOperation(dataObj);
      }
    });
  }

  randomId() {
    const possConns = this.inConns.filter(conn => this.peer.id !== conn.peer);
    const randomIdx = Math.floor(Math.random() * possConns.length);

    if (possConns[randomIdx]) {
      return possConns[randomIdx].peer;
    } else {
      return null;
    }
  }

  onConnClose(connection) {
    connection.on('close', () => {
      this.removeFromConnections(connection.peer);

      if (!this.hasReachedMax()) {
        this.controller.findNewTarget();
      }
    });
  }

}

/* harmony default export */ __webpack_exports__["default"] = (Broadcast);

/***/ }),

/***/ "./src/routes/webrtc/conclave/char.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class Char {
  constructor(value, counter, siteId, identifiers) {
    this.position = identifiers;
    this.counter = counter;
    this.siteId = siteId;
    this.value = value;
  }

  compareTo(otherChar) {
    let comp;
    let id1;
    let id2;
    const pos1 = this.position;
    const pos2 = otherChar.position;

    for (let i = 0; i < Math.min(pos1.length, pos2.length); i++) {
      id1 = pos1[i];
      id2 = pos2[i];
      comp = id1.compareTo(id2);

      if (comp !== 0) {
        return comp;
      }
    }

    if (pos1.length < pos2.length) {
      return -1;
    } else if (pos1.length > pos2.length) {
      return 1;
    } else {
      return 0;
    }
  }

}

/* harmony default export */ __webpack_exports__["default"] = (Char);

/***/ }),

/***/ "./src/routes/webrtc/conclave/controller.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var peerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("peerjs");
/* harmony import */ var peerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(peerjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _crdt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/routes/webrtc/conclave/crdt.js");
/* harmony import */ var _char__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/routes/webrtc/conclave/char.js");
/* harmony import */ var _identifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/routes/webrtc/conclave/identifier.js");
/* harmony import */ var _versionVector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/routes/webrtc/conclave/versionVector.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/routes/webrtc/conclave/version.js");
/* harmony import */ var _broadcast__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/routes/webrtc/conclave/broadcast.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









class Controller {
  constructor(siteId, targetPeerId, host, peer) {
    _defineProperty(this, "siteId", void 0);

    _defineProperty(this, "host", void 0);

    _defineProperty(this, "buffer", void 0);

    _defineProperty(this, "network", void 0);

    _defineProperty(this, "urlId", void 0);

    _defineProperty(this, "dispatch", void 0);

    _defineProperty(this, "broadcast", void 0);

    _defineProperty(this, "vector", void 0);

    _defineProperty(this, "crdt", void 0);

    this.siteId = siteId;
    this.host = host;
    this.buffer = [];
    this.network = [];
    this.urlId = targetPeerId; // $FlowExpectError - passing not fully initialized object

    this.broadcast = new _broadcast__WEBPACK_IMPORTED_MODULE_6__["default"](this, peer, targetPeerId);
    this.vector = new _versionVector__WEBPACK_IMPORTED_MODULE_4__["default"](this.siteId);
    this.crdt = new _crdt__WEBPACK_IMPORTED_MODULE_1__["default"](this);
  }

  lostConnection() {
    console.log('disconnected');
  }

  populateCRDT(initialStruct) {
    const struct = initialStruct.map(line => line.map(ch => new _char__WEBPACK_IMPORTED_MODULE_2__["default"](ch.value, ch.counter, ch.siteId, ch.position.map(id => new _identifier__WEBPACK_IMPORTED_MODULE_3__["default"](id.digit, id.siteId)))));
    this.crdt.struct = struct;
  }

  populateVersionVector(initialVersions) {
    const versions = initialVersions.map(ver => {
      const version = new _version__WEBPACK_IMPORTED_MODULE_5__["default"](ver.siteId);
      version.counter = ver.counter;
      ver.exceptions.forEach(ex => version.exceptions.push(ex));
      return version;
    });
    versions.forEach(version => this.vector.versions.push(version));
  }

  addToNetwork(peerId, siteId) {
    if (!this.network.find(obj => obj.siteId === siteId)) {
      this.network.push({
        peerId,
        siteId
      });
      this.broadcast.addToNetwork(peerId, siteId);
    }
  }

  removeFromNetwork(peerId) {
    const peerObj = this.network.find(obj => obj.peerId === peerId);
    const idx = this.network.indexOf(peerObj);

    if (idx >= 0) {
      const [{
        siteId
      }] = this.network.splice(idx, 1);
      this.dispatch({
        type: 'REMOVE_CURSOR',
        siteId
      });
      this.broadcast.removeFromNetwork(peerId);
    }
  }

  findNewTarget() {
    const connected = this.broadcast.outConns.map(conn => conn.peer);
    const unconnected = this.network.filter(obj => connected.indexOf(obj.peerId) === -1);
    const possibleTargets = unconnected.filter(obj => obj.peerId !== this.broadcast.peer.id);

    if (possibleTargets.length > 0) {
      const randomIdx = Math.floor(Math.random() * possibleTargets.length);
      const newTarget = possibleTargets[randomIdx].peerId;
      this.broadcast.requestConnection(newTarget, this.broadcast.peer.id, this.siteId);
    }
  }

  handleSync(syncObj) {
    syncObj.network.forEach(obj => this.addToNetwork(obj.peerId, obj.siteId));

    if (this.crdt.totalChars() === 0) {
      this.populateCRDT(syncObj.initialStruct);
      this.populateVersionVector(syncObj.initialVersions);
    }

    this.syncCompleted(syncObj.peerId);
  }

  syncCompleted(peerId) {
    const completedMessage = JSON.stringify({
      type: 'syncCompleted',
      peerId: this.broadcast.peer.id
    });
    let existingConnection = this.broadcast.outConns.find(conn => conn.peer === peerId);

    if (existingConnection) {
      existingConnection.send(completedMessage);
    } else {
      let newConnection = this.broadcast.peer.connect(peerId);
      this.broadcast.addToOutConns(newConnection);
      newConnection.on('open', () => {
        newConnection.send(completedMessage);
      });
    }
  }

  handleRemoteOperation(operation) {
    if (this.vector.hasBeenApplied(operation.version)) return;

    if (operation.type === 'insert') {
      this.applyOperation(operation);
    } else if (operation.type === 'delete') {
      this.buffer.push(operation);
    }

    this.processDeletionBuffer();
    this.broadcast.send(operation);
  }

  processDeletionBuffer() {
    let i = 0;
    let deleteOperation;

    while (i < this.buffer.length) {
      deleteOperation = this.buffer[i];

      if (this.hasInsertionBeenApplied(deleteOperation)) {
        this.applyOperation(deleteOperation);
        this.buffer.splice(i, 1);
      } else {
        i += 1;
      }
    }
  }

  hasInsertionBeenApplied(operation) {
    const charVersion = {
      siteId: operation.char.siteId,
      counter: operation.char.counter
    };
    return this.vector.hasBeenApplied(charVersion);
  }

  applyOperation(operation) {
    const {
      char
    } = operation;
    const identifiers = char.position.map(pos => new _identifier__WEBPACK_IMPORTED_MODULE_3__["default"](pos.digit, pos.siteId));
    const newChar = new _char__WEBPACK_IMPORTED_MODULE_2__["default"](char.value, char.counter, char.siteId, identifiers);

    if (operation.type === 'insert') {
      this.crdt.handleRemoteInsert(newChar);
    } else if (operation.type === 'delete') {
      this.crdt.handleRemoteDelete(newChar, operation.version.siteId);
    }

    this.vector.update(operation.version);
  }

  localDelete(startPos, endPos) {
    this.crdt.handleLocalDelete(startPos, endPos);
  }

  localInsert(lines, startPos) {
    for (const [i, line] of lines.entries()) {
      for (const char of line) {
        this.crdt.handleLocalInsert(char, startPos);
        startPos.ch += 1;
      }

      if (i !== lines.length - 1) {
        // after each line, insert a newline
        this.crdt.handleLocalInsert('\n', startPos);
      }

      startPos.line += 1;
      startPos.ch = 0;
    }
  }

  broadcastInsertion(char) {
    const operation = {
      type: 'insert',
      char,
      version: this.vector.getLocalVersion()
    };
    this.broadcast.send(operation);
  }

  broadcastDeletion(char, version) {
    const operation = {
      type: 'delete',
      char,
      version
    };
    this.broadcast.send(operation);
  }

  insertIntoEditor(value, pos, siteId) {
    const start = {
      row: pos.line,
      column: pos.ch
    };
    const end = {
      row: pos.line,
      column: pos.ch
    };
    this.dispatch({
      type: 'INSERT',
      siteId,
      value,
      start,
      end
    });
  }

  deleteFromEditor(value, pos, siteId) {
    const start = {
      row: pos.line,
      column: pos.ch
    };
    const end = value === '\n' ? {
      row: pos.line + 1,
      column: 0
    } : {
      row: pos.line,
      column: pos.ch + 1
    };
    this.dispatch({
      type: 'DELETE',
      siteId,
      value,
      start,
      end
    });
  }

}

/* harmony default export */ __webpack_exports__["default"] = (Controller);

/***/ }),

/***/ "./src/routes/webrtc/conclave/crdt.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _identifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/routes/webrtc/conclave/identifier.js");
/* harmony import */ var _char__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/routes/webrtc/conclave/char.js");
/* eslint-disable */



class CRDT {
  constructor(controller, base = 32, boundary = 10, strategy = 'random') {
    this.controller = controller;
    this.vector = controller.vector;
    this.struct = [[]];
    this.siteId = controller.siteId;
    this.base = base;
    this.boundary = boundary;
    this.strategy = strategy;
    this.strategyCache = [];
  }

  handleLocalInsert(value, pos) {
    this.vector.increment();
    const char = this.generateChar(value, pos);
    this.insertChar(char, pos);
    this.controller.broadcastInsertion(char);
  }

  handleRemoteInsert(char) {
    const pos = this.findInsertPosition(char);
    this.insertChar(char, pos);
    this.controller.insertIntoEditor(char.value, pos, char.siteId);
  }

  insertChar(char, pos) {
    if (pos.line === this.struct.length) {
      this.struct.push([]);
    } // if inserting a newline, split line into two lines


    if (char.value === '\n') {
      const lineAfter = this.struct[pos.line].splice(pos.ch);

      if (lineAfter.length === 0) {
        this.struct[pos.line].splice(pos.ch, 0, char);
      } else {
        const lineBefore = this.struct[pos.line].concat(char);
        this.struct.splice(pos.line, 1, lineBefore, lineAfter);
      }
    } else {
      this.struct[pos.line].splice(pos.ch, 0, char);
    }
  }

  handleLocalDelete(startPos, endPos) {
    let chars;
    let newlineRemoved = false; // for multi-line deletes

    if (startPos.line !== endPos.line) {
      // delete chars on first line from startPos.ch to end of line
      newlineRemoved = true;
      chars = this.deleteMultipleLines(startPos, endPos); // single-line deletes
    } else {
      chars = this.deleteSingleLine(startPos, endPos);
      if (chars.find(char => char.value === '\n')) newlineRemoved = true;
    }

    this.broadcast(chars);
    this.removeEmptyLines();

    if (newlineRemoved && this.struct[startPos.line + 1]) {
      this.mergeLines(startPos.line);
    }
  }

  broadcast(chars) {
    chars.forEach(char => {
      this.vector.increment();
      this.controller.broadcastDeletion(char, this.vector.getLocalVersion());
    });
  }

  deleteMultipleLines(startPos, endPos) {
    let chars = this.struct[startPos.line].splice(startPos.ch);
    let line;

    for (line = startPos.line + 1; line < endPos.line; line++) {
      chars = chars.concat(this.struct[line].splice(0));
    } // todo for loop inside crdt


    if (this.struct[endPos.line]) {
      chars = chars.concat(this.struct[endPos.line].splice(0, endPos.ch));
    }

    return chars;
  }

  deleteSingleLine(startPos, endPos) {
    const charNum = endPos.ch - startPos.ch;
    const chars = this.struct[startPos.line].splice(startPos.ch, charNum);
    return chars;
  } // when deleting newline, concat line with next line


  mergeLines(line) {
    const mergedLine = this.struct[line].concat(this.struct[line + 1]);
    this.struct.splice(line, 2, mergedLine);
  }

  removeEmptyLines() {
    for (let line = 0; line < this.struct.length; line++) {
      if (this.struct[line].length === 0) {
        this.struct.splice(line, 1);
        line--;
      }
    }

    if (this.struct.length === 0) {
      this.struct.push([]);
    }
  }

  handleRemoteDelete(char, siteId) {
    const pos = this.findPosition(char);
    if (!pos) return;
    this.struct[pos.line].splice(pos.ch, 1);

    if (char.value === '\n' && this.struct[pos.line + 1]) {
      this.mergeLines(pos.line);
    }

    this.removeEmptyLines();
    this.controller.deleteFromEditor(char.value, pos, siteId);
  }

  isEmpty() {
    return this.struct.length === 1 && this.struct[0].length === 0;
  }

  findPosition(char) {
    let minLine = 0;
    const totalLines = this.struct.length;
    let maxLine = totalLines - 1;
    const lastLine = this.struct[maxLine];
    let currentLine;
    let midLine;
    let charIdx;
    let minCurrentLine;
    let lastChar;
    let maxCurrentLine;
    let minLastChar;
    let maxLastChar; // check if struct is empty or char is less than first char

    if (this.isEmpty() || char.compareTo(this.struct[0][0]) < 0) {
      return false;
    }

    lastChar = lastLine[lastLine.length - 1]; // char is greater than all existing chars (insert at end)

    if (char.compareTo(lastChar) > 0) {
      return false;
    } // binary search


    while (minLine + 1 < maxLine) {
      midLine = Math.floor(minLine + (maxLine - minLine) / 2);
      currentLine = this.struct[midLine];
      lastChar = currentLine[currentLine.length - 1];

      if (char.compareTo(lastChar) === 0) {
        return {
          line: midLine,
          ch: currentLine.length - 1
        };
      } else if (char.compareTo(lastChar) < 0) {
        maxLine = midLine;
      } else {
        minLine = midLine;
      }
    } // Check between min and max line.


    minCurrentLine = this.struct[minLine];
    minLastChar = minCurrentLine[minCurrentLine.length - 1];
    maxCurrentLine = this.struct[maxLine];
    maxLastChar = maxCurrentLine[maxCurrentLine.length - 1];

    if (char.compareTo(minLastChar) <= 0) {
      charIdx = this.findIndexInLine(char, minCurrentLine);
      return {
        line: minLine,
        ch: charIdx
      };
    } else {
      charIdx = this.findIndexInLine(char, maxCurrentLine);
      return {
        line: maxLine,
        ch: charIdx
      };
    }
  }

  findIndexInLine(char, line) {
    let left = 0;
    let right = line.length - 1;
    let mid;
    let compareNum;

    if (line.length === 0 || char.compareTo(line[left]) < 0) {
      return left;
    } else if (char.compareTo(line[right]) > 0) {
      return this.struct.length;
    }

    while (left + 1 < right) {
      mid = Math.floor(left + (right - left) / 2);
      compareNum = char.compareTo(line[mid]);

      if (compareNum === 0) {
        return mid;
      } else if (compareNum > 0) {
        left = mid;
      } else {
        right = mid;
      }
    }

    if (char.compareTo(line[left]) === 0) {
      return left;
    } else if (char.compareTo(line[right]) === 0) {
      return right;
    } else {
      return false;
    }
  } // could be refactored to look prettier


  findInsertPosition(char) {
    let minLine = 0;
    const totalLines = this.struct.length;
    let maxLine = totalLines - 1;
    const lastLine = this.struct[maxLine];
    let currentLine;
    let midLine;
    let charIdx;
    let minCurrentLine;
    let lastChar;
    let maxCurrentLine;
    let minLastChar;
    let maxLastChar; // check if struct is empty or char is less than first char

    if (this.isEmpty() || char.compareTo(this.struct[0][0]) <= 0) {
      return {
        line: 0,
        ch: 0
      };
    }

    lastChar = lastLine[lastLine.length - 1]; // char is greater than all existing chars (insert at end)

    if (char.compareTo(lastChar) > 0) {
      return this.findEndPosition(lastChar, lastLine, totalLines);
    } // binary search


    while (minLine + 1 < maxLine) {
      midLine = Math.floor(minLine + (maxLine - minLine) / 2);
      currentLine = this.struct[midLine];
      lastChar = currentLine[currentLine.length - 1];

      if (char.compareTo(lastChar) === 0) {
        return {
          line: midLine,
          ch: currentLine.length - 1
        };
      } else if (char.compareTo(lastChar) < 0) {
        maxLine = midLine;
      } else {
        minLine = midLine;
      }
    } // Check between min and max line.


    minCurrentLine = this.struct[minLine];
    minLastChar = minCurrentLine[minCurrentLine.length - 1];
    maxCurrentLine = this.struct[maxLine];
    maxLastChar = maxCurrentLine[maxCurrentLine.length - 1];

    if (char.compareTo(minLastChar) <= 0) {
      charIdx = this.findInsertIndexInLine(char, minCurrentLine);
      return {
        line: minLine,
        ch: charIdx
      };
    } else {
      charIdx = this.findInsertIndexInLine(char, maxCurrentLine);
      return {
        line: maxLine,
        ch: charIdx
      };
    }
  }

  findEndPosition(lastChar, lastLine, totalLines) {
    if (lastChar.value === '\n') {
      return {
        line: totalLines,
        ch: 0
      };
    } else {
      return {
        line: totalLines - 1,
        ch: lastLine.length
      };
    }
  } // binary search to find char in a line


  findInsertIndexInLine(char, line) {
    let left = 0;
    let right = line.length - 1;
    let mid;
    let compareNum;

    if (line.length === 0 || char.compareTo(line[left]) < 0) {
      return left;
    } else if (char.compareTo(line[right]) > 0) {
      return this.struct.length;
    }

    while (left + 1 < right) {
      mid = Math.floor(left + (right - left) / 2);
      compareNum = char.compareTo(line[mid]);

      if (compareNum === 0) {
        return mid;
      } else if (compareNum > 0) {
        left = mid;
      } else {
        right = mid;
      }
    }

    if (char.compareTo(line[left]) === 0) {
      return left;
    } else {
      return right;
    }
  }

  findPosBefore(pos) {
    let {
      ch
    } = pos;
    let {
      line
    } = pos;

    if (ch === 0 && line === 0) {
      return [];
    } else if (ch === 0 && line !== 0) {
      line -= 1;
      ch = this.struct[line].length;
    }

    return this.struct[line][ch - 1].position;
  }

  findPosAfter(pos) {
    let {
      ch
    } = pos;
    let {
      line
    } = pos;
    const numLines = this.struct.length;
    const numChars = this.struct[line] && this.struct[line].length || 0;

    if (line === numLines - 1 && ch === numChars) {
      return [];
    } else if (line < numLines - 1 && ch === numChars) {
      line += 1;
      ch = 0;
    } else if (line > numLines - 1 && ch === 0) {
      return [];
    }

    return this.struct[line][ch].position;
  }

  generateChar(val, pos) {
    const posBefore = this.findPosBefore(pos);
    const posAfter = this.findPosAfter(pos);
    const newPos = this.generatePosBetween(posBefore, posAfter);
    return new _char__WEBPACK_IMPORTED_MODULE_1__["default"](val, this.vector.localVersion.counter, this.siteId, newPos);
  }

  retrieveStrategy(level) {
    if (this.strategyCache[level]) return this.strategyCache[level];
    let strategy;

    switch (this.strategy) {
      case 'plus':
        strategy = '+';

      case 'minus':
        strategy = '-';

      case 'random':
        strategy = Math.round(Math.random()) === 0 ? '+' : '-';

      default:
        strategy = level % 2 === 0 ? '+' : '-';
    }

    this.strategyCache[level] = strategy;
    return strategy;
  }

  generatePosBetween(pos1, pos2, newPos = [], level = 0) {
    // change 2 to any other number to change base multiplication
    const base = Math.pow(2, level) * this.base;
    const boundaryStrategy = this.retrieveStrategy(level);
    const id1 = pos1[0] || new _identifier__WEBPACK_IMPORTED_MODULE_0__["default"](0, this.siteId);
    const id2 = pos2[0] || new _identifier__WEBPACK_IMPORTED_MODULE_0__["default"](base, this.siteId);

    if (id2.digit - id1.digit > 1) {
      const newDigit = this.generateIdBetween(id1.digit, id2.digit, boundaryStrategy);
      newPos.push(new _identifier__WEBPACK_IMPORTED_MODULE_0__["default"](newDigit, this.siteId));
      return newPos;
    } else if (id2.digit - id1.digit === 1) {
      newPos.push(id1);
      return this.generatePosBetween(pos1.slice(1), [], newPos, level + 1);
    } else if (id1.digit === id2.digit) {
      if (id1.siteId < id2.siteId) {
        newPos.push(id1);
        return this.generatePosBetween(pos1.slice(1), [], newPos, level + 1);
      } else if (id1.siteId === id2.siteId) {
        newPos.push(id1);
        return this.generatePosBetween(pos1.slice(1), pos2.slice(1), newPos, level + 1);
      } else {
        throw new Error('Fix Position Sorting');
      }
    }
  }
  /*
  Math.random gives you a range that is inclusive of the min and exclusive of the max
  so have to add and subtract ones to get them all into that format
  if max - min <= boundary, the boundary doesn't matter
    newDigit > min, newDigit < max
    ie (min+1...max)
    so, min = min + 1
  if max - min > boundary and the boundary is negative
    min = max - boundary
    newDigit >= min, newDigit < max
    ie (min...max)
  if max - min > boundary and the boundary is positive
    max = min + boundary
    newDigit > min, newDigit <= max
    ie (min+1...max+1)
    so, min = min + 1 and max = max + 1
  now all are (min...max)
  */


  generateIdBetween(min, max, boundaryStrategy) {
    if (max - min < this.boundary) {
      min += 1;
    } else if (boundaryStrategy === '-') {
      min = max - this.boundary;
    } else {
      min += 1;
      max = min + this.boundary;
    }

    return Math.floor(Math.random() * (max - min)) + min;
  }

  totalChars() {
    return this.struct.map(line => line.length).reduce((acc, val) => acc + val);
  }

  toText() {
    return this.struct.map(line => line.map(char => char.value).join('')).join('');
  }

}

/* harmony default export */ __webpack_exports__["default"] = (CRDT);

/***/ }),

/***/ "./src/routes/webrtc/conclave/identifier.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class Identifier {
  constructor(digit, siteId) {
    this.digit = digit;
    this.siteId = siteId;
  } // Compare identifiers using their digit value with siteID as the tiebreaker
  // If identifers are equal, return 0


  compareTo(otherId) {
    if (this.digit < otherId.digit) {
      return -1;
    } else if (this.digit > otherId.digit) {
      return 1;
    } else if (this.siteId < otherId.siteId) {
      return -1;
    } else if (this.siteId > otherId.siteId) {
      return 1;
    } else {
      return 0;
    }
  }

}

/* harmony default export */ __webpack_exports__["default"] = (Identifier);

/***/ }),

/***/ "./src/routes/webrtc/conclave/version.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Class that wraps the information about each version.
// exceptions are a set of counters for operations that our local CRDT has not
// seen or integrated yet. Waiting for these operations.
class Version {
  constructor(siteId) {
    _defineProperty(this, "siteId", void 0);

    _defineProperty(this, "counter", void 0);

    _defineProperty(this, "exceptions", void 0);

    this.siteId = siteId;
    this.counter = 0;
    this.exceptions = [];
  } // Update a site's version based on the incoming operation that was processed
  // If the incomingCounter is less than we had previously processed, we can remove it from the exceptions
  // Else if the incomingCounter is the operation immediately after the last one we procesed, we just increment our counter to reflect that
  // Else, add an exception for each counter value that we haven't seen yet, and update our counter to match


  update(version) {
    const incomingCounter = version.counter;

    if (incomingCounter <= this.counter) {
      const index = this.exceptions.indexOf(incomingCounter);
      this.exceptions.splice(index, 1);
    } else if (incomingCounter === this.counter + 1) {
      this.counter += 1;
    } else {
      for (let i = this.counter + 1; i < incomingCounter; i += 1) {
        this.exceptions.push(i);
      }

      this.counter = incomingCounter;
    }
  }

}

/* harmony default export */ __webpack_exports__["default"] = (Version);

/***/ }),

/***/ "./src/routes/webrtc/conclave/versionVector.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/routes/webrtc/conclave/version.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

 // vector/list of versions of sites in the distributed system
// keeps track of the latest operation received from each site (i.e. version)
// prevents duplicate operations from being applied to our CRDT

class VersionVector {
  // initialize empty vector to be sorted by siteId
  // initialize Version/Clock for local site and insert into versions vector object
  constructor(siteId) {
    _defineProperty(this, "localVersion", void 0);

    _defineProperty(this, "versions", void 0);

    this.localVersion = new _version__WEBPACK_IMPORTED_MODULE_0__["default"](siteId);
    this.versions = [this.localVersion];
  }

  increment() {
    this.localVersion.counter += 1;
  } // updates vector with new version received from another site
  // if vector doesn't contain version, it's created and added to vector
  // create exceptions if need be.


  update(incomingVersion) {
    const existingVersion = this.versions.find(version => incomingVersion.siteId === version.siteId);

    if (!existingVersion) {
      const newVersion = new _version__WEBPACK_IMPORTED_MODULE_0__["default"](incomingVersion.siteId);
      newVersion.update(incomingVersion);
      this.versions.push(newVersion);
    } else {
      existingVersion.update(incomingVersion);
    }
  } // check if incoming remote operation has already been applied to our crdt


  hasBeenApplied(incomingVersion) {
    const localIncomingVersion = this.getVersionFromVector(incomingVersion);
    if (!localIncomingVersion) return false;
    const isIncomingLower = incomingVersion.counter <= localIncomingVersion.counter;
    const isInExceptions = localIncomingVersion.exceptions.includes(incomingVersion.counter);
    return isIncomingLower && !isInExceptions;
  }

  getVersionFromVector(incomingVersion) {
    return this.versions.find(version => version.siteId === incomingVersion.siteId);
  }

  getLocalVersion() {
    const {
      siteId,
      counter
    } = this.localVersion;
    return {
      siteId,
      counter
    };
  }

}

/* harmony default export */ __webpack_exports__["default"] = (VersionVector);

/***/ }),

/***/ "./src/routes/webrtc/useConclave.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return useConclave; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var peerjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("peerjs");
/* harmony import */ var peerjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(peerjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_misc_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/components/misc/hooks/index.js");
/* harmony import */ var _useRemoteCursors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/routes/webrtc/useRemoteCursors.js");
/* harmony import */ var _useContent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/routes/webrtc/useContent.js");
/* harmony import */ var _conclave_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/routes/webrtc/conclave/controller.js");






function useConclave(connectionConfig, getMarkerClassName) {
  const remoteCursors = Object(_useRemoteCursors__WEBPACK_IMPORTED_MODULE_3__["default"])(getMarkerClassName);
  const remoteCursorsDispatch = remoteCursors.dispatch;
  const controller = _components_misc_hooks__WEBPACK_IMPORTED_MODULE_2__["useValue"](() => {
    const {
      peerOptions,
      onOpen,
      siteId,
      targetPeerId
    } = connectionConfig; // eslint-disable-next-line no-shadow

    const controller = new _conclave_controller__WEBPACK_IMPORTED_MODULE_5__["default"](siteId, targetPeerId, // eslint-disable-next-line no-restricted-globals
    location.origin, new peerjs__WEBPACK_IMPORTED_MODULE_1___default.a({ ...peerOptions,
      debug: 1
    }));
    if (onOpen) controller.broadcast.peer.on('open', onOpen);
    setTimeout(() => {
      remoteCursors.dispatch({
        type: 'SET',
        siteId: 'foo',
        remoteCursor: {
          selection: {
            start: {
              row: 1,
              column: 1
            },
            end: {
              row: 1,
              column: 3
            }
          },
          cursor: {
            row: 1,
            column: 3
          }
        }
      });
    }, 5000);
    return controller;
  });
  const content = Object(_useContent__WEBPACK_IMPORTED_MODULE_4__["default"])(remoteCursorsDispatch, controller);
  const contentRefresh = content.refreshValue;
  react__WEBPACK_IMPORTED_MODULE_0__["useEffect"](() => {
    function dispatch(action) {
      switch (action.type) {
        case 'REMOVE_CURSOR':
          {
            const {
              siteId
            } = action;
            remoteCursorsDispatch({
              type: 'REMOVE',
              siteId
            });
            break;
          }

        case 'INSERT':
          {
            contentRefresh();
            break;
          }

        case 'DELETE':
          {
            contentRefresh();
            break;
          }

        default:
          // eslint-disable-next-line no-throw-literal
          throw 'unreachable';
      }
    }

    controller.dispatch = dispatch;
  }, [controller, remoteCursorsDispatch, contentRefresh]);
  return {
    mountAceEditor(config) {
      const {
        markers,
        ...props
      } = config !== null && config !== void 0 ? config : {};
      return { ...props,
        markers: [...(markers !== null && markers !== void 0 ? markers : []), ...remoteCursors.getAceMarkers()],
        onChange: content.onChange,
        value: content.value
      };
    }

  };
}

/***/ }),

/***/ "./src/routes/webrtc/useContent.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return useContent; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _conclave_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/routes/webrtc/conclave/controller.js");


function useContent(remoteCursorsDispatch, controller) {
  const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_0__["useState"]('');

  function refreshValue() {
    setValue(controller.crdt.toText());
  }

  return {
    value,
    refreshValue,

    onChange(_value, {
      action,
      lines,
      start,
      end
    }) {
      switch (action) {
        case 'insert':
          {
            remoteCursorsDispatch({
              type: 'INSERT',
              start,
              end
            });
            controller.localInsert(lines, {
              line: start.row,
              ch: start.column
            });
            refreshValue();
            break;
          }

        case 'remove':
          {
            remoteCursorsDispatch({
              type: 'DELETE',
              start,
              end
            });
            controller.localDelete({
              line: start.row,
              ch: start.column
            }, {
              line: end.row,
              ch: end.column
            });
            refreshValue();
            break;
          }

        default:
          // eslint-disable-next-line no-throw-literal
          throw 'unreachable';
      }
    }

  };
}

/***/ }),

/***/ "./src/routes/webrtc/useRemoteCursors.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return useRemoteCursors; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/util.js");



function remoteCursorsReducer(state, action) {
  function mapRemoteCursor(fn) {
    return ({
      selection,
      cursor
    }) => {
      if (selection !== null) {
        selection = {
          start: fn(selection.start),
          end: fn(selection.end)
        };
      }

      if (cursor !== null) {
        cursor = fn(cursor);
      }

      return {
        selection,
        cursor
      };
    };
  }

  switch (action.type) {
    case 'SET':
      {
        const {
          siteId,
          remoteCursor
        } = action;
        return { ...state,
          [siteId]: remoteCursor
        };
      }

    case 'REMOVE':
      {
        const {
          siteId
        } = action;
        const {
          [siteId]: _,
          ...newState
        } = state;
        return newState;
      }

    case 'INSERT':
      {
        const {
          start,
          end
        } = action;
        const rowDelta = end.row - start.row;
        const columnDelta = rowDelta === 0 ? end.column - start.column : end.column;

        function mapPosition({
          row,
          column
        }) {
          if (row > start.row) {
            // the position was shifted down a number of lines
            return {
              row: row + rowDelta,
              column
            };
          } else if (row === start.row && column > start.column) {
            if (rowDelta > 0) {
              // the position was shifted to a new line,
              // shift left the number of characters remaining on the old line
              return {
                row: row + rowDelta,
                column: column - start.column
              };
            } else {
              // the position was shifted within the line
              return {
                row,
                column: column + columnDelta
              };
            }
          } else {
            // the position was not shifted
            return {
              row,
              column
            };
          }
        }

        return Object(_util__WEBPACK_IMPORTED_MODULE_1__["mapObject"])(state, mapRemoteCursor(mapPosition));
      }

    case 'DELETE':
      {
        const {
          start,
          end
        } = action;
        const rowDelta = end.row - start.row;
        const columnDelta = rowDelta === 0 ? end.column - start.column : end.column;

        function mapPosition({
          row,
          column
        }) {
          if (row > end.row) {
            // the position was shifted up a number of lines
            return {
              row: row - rowDelta,
              column
            };
          } else if (row === end.row && column > end.column) {
            if (rowDelta > 0) {
              // the position was shifted to a new line,
              // shift right the number of characters remaining on the new line
              return {
                row: row - rowDelta,
                column: column + start.column
              };
            } else {
              // the position was shifted within the line
              return {
                row,
                column: column - columnDelta
              };
            }
          } else {
            // the position was not shifted
            return {
              row,
              column
            };
          }
        }

        return Object(_util__WEBPACK_IMPORTED_MODULE_1__["mapObject"])(state, mapRemoteCursor(mapPosition));
      }

    default:
      // eslint-disable-next-line no-throw-literal
      throw 'unreachable';
  }
}

function useRemoteCursors(getClassName) {
  const [cursors, dispatch] = react__WEBPACK_IMPORTED_MODULE_0__["useReducer"](remoteCursorsReducer, {
    foo: {
      selection: {
        start: {
          row: 0,
          column: 1
        },
        end: {
          row: 0,
          column: 3
        }
      },
      cursor: {
        row: 0,
        column: 3
      }
    }
  });
  return {
    dispatch,

    getAceMarkers() {
      const markers = [];

      for (const [siteId, remoteCursor] of Object.entries(cursors)) {
        // $FlowExpectError
        const {
          selection,
          cursor
        } = remoteCursor;

        if (selection !== null) {
          markers.push({
            startRow: selection.start.row,
            startCol: selection.start.column,
            endRow: selection.end.row,
            endCol: selection.end.column,
            className: getClassName(siteId, 'selection'),
            type: 'text'
          });
        }

        if (cursor !== null) {
          markers.push({
            startRow: cursor.row,
            startCol: cursor.column,
            endRow: cursor.row,
            endCol: cursor.column + 1,
            className: getClassName(siteId, 'cursor'),
            type: 'text'
          });
        }
      }

      return markers;
    }

  };
}

/***/ }),

/***/ "./src/util.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "promisify", function() { return promisify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapObject", function() { return mapObject; });
/* eslint-disable import/prefer-default-export */
// takes a function that takes a callback `(err, result) => ...`
// as its last parameter and makes it into a function that returns a promise instead
// Flow doesn't manage to capture the type of `(...args, cb) => void` unfortunately,
// so the actual type of the promise can not be inferred, and argument types are not checked.
function promisify(fn) {
  return (...args) => new Promise((resolve, reject) => {
    fn(...args, (err, result) => {
      if (err) reject(err);else resolve(result);
    });
  });
}
function mapObject(obj, fn) {
  const entries = Object.entries(obj);
  const newEntries = entries.map(([key, value0]) => {
    // $FlowExpectError
    const value = value0;
    return [key, fn(value, key)];
  });
  return Object.fromEntries(newEntries);
}

/***/ })

};;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzLzMuanMiLCJzb3VyY2VzIjpbIi9ob21lL3NhcmFoL0RvY3VtZW50cy9BcmJlaXQvZ2l0aHViL25ldFJvYi9OZXRyb2Ivc3JjL3JvdXRlcy93ZWJydGMvV2ViUlRDLnNjc3MiLCIvaG9tZS9zYXJhaC9Eb2N1bWVudHMvQXJiZWl0L2dpdGh1Yi9uZXRSb2IvTmV0cm9iL3NyYy9yb3V0ZXMvd2VicnRjL0FjZVBlZXJFZGl0b3IuanMiLCIvaG9tZS9zYXJhaC9Eb2N1bWVudHMvQXJiZWl0L2dpdGh1Yi9uZXRSb2IvTmV0cm9iL3NyYy9yb3V0ZXMvd2VicnRjL1dlYlJUQy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcm91dGVzL3dlYnJ0Yy9XZWJSVEMuc2Nzcz9hMGNjIiwiL2hvbWUvc2FyYWgvRG9jdW1lbnRzL0FyYmVpdC9naXRodWIvbmV0Um9iL05ldHJvYi9zcmMvcm91dGVzL3dlYnJ0Yy9jb25jbGF2ZS9icm9hZGNhc3QuanMiLCIvaG9tZS9zYXJhaC9Eb2N1bWVudHMvQXJiZWl0L2dpdGh1Yi9uZXRSb2IvTmV0cm9iL3NyYy9yb3V0ZXMvd2VicnRjL2NvbmNsYXZlL2NoYXIuanMiLCIvaG9tZS9zYXJhaC9Eb2N1bWVudHMvQXJiZWl0L2dpdGh1Yi9uZXRSb2IvTmV0cm9iL3NyYy9yb3V0ZXMvd2VicnRjL2NvbmNsYXZlL2NvbnRyb2xsZXIuanMiLCIvaG9tZS9zYXJhaC9Eb2N1bWVudHMvQXJiZWl0L2dpdGh1Yi9uZXRSb2IvTmV0cm9iL3NyYy9yb3V0ZXMvd2VicnRjL2NvbmNsYXZlL2NyZHQuanMiLCIvaG9tZS9zYXJhaC9Eb2N1bWVudHMvQXJiZWl0L2dpdGh1Yi9uZXRSb2IvTmV0cm9iL3NyYy9yb3V0ZXMvd2VicnRjL2NvbmNsYXZlL2lkZW50aWZpZXIuanMiLCIvaG9tZS9zYXJhaC9Eb2N1bWVudHMvQXJiZWl0L2dpdGh1Yi9uZXRSb2IvTmV0cm9iL3NyYy9yb3V0ZXMvd2VicnRjL2NvbmNsYXZlL3ZlcnNpb24uanMiLCIvaG9tZS9zYXJhaC9Eb2N1bWVudHMvQXJiZWl0L2dpdGh1Yi9uZXRSb2IvTmV0cm9iL3NyYy9yb3V0ZXMvd2VicnRjL2NvbmNsYXZlL3ZlcnNpb25WZWN0b3IuanMiLCIvaG9tZS9zYXJhaC9Eb2N1bWVudHMvQXJiZWl0L2dpdGh1Yi9uZXRSb2IvTmV0cm9iL3NyYy9yb3V0ZXMvd2VicnRjL3VzZUNvbmNsYXZlLmpzIiwiL2hvbWUvc2FyYWgvRG9jdW1lbnRzL0FyYmVpdC9naXRodWIvbmV0Um9iL05ldHJvYi9zcmMvcm91dGVzL3dlYnJ0Yy91c2VDb250ZW50LmpzIiwiL2hvbWUvc2FyYWgvRG9jdW1lbnRzL0FyYmVpdC9naXRodWIvbmV0Um9iL05ldHJvYi9zcmMvcm91dGVzL3dlYnJ0Yy91c2VSZW1vdGVDdXJzb3JzLmpzIiwiL2hvbWUvc2FyYWgvRG9jdW1lbnRzL0FyYmVpdC9naXRodWIvbmV0Um9iL05ldHJvYi9zcmMvdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyoqXFxuICogUmVhY3QgU3RhcnRlciBLaXQgKGh0dHBzOi8vd3d3LnJlYWN0c3RhcnRlcmtpdC5jb20vKVxcbiAqXFxuICogQ29weXJpZ2h0IMKpIDIwMTQtcHJlc2VudCBLcmlhc29mdCwgTExDLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKi9cXG5cXG4vKipcXG4gKiBSZWFjdCBTdGFydGVyIEtpdCAoaHR0cHM6Ly93d3cucmVhY3RzdGFydGVya2l0LmNvbS8pXFxuICpcXG4gKiBDb3B5cmlnaHQgwqkgMjAxNC1wcmVzZW50IEtyaWFzb2Z0LCBMTEMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqL1xcblxcbjpyb290IHtcXG4gIC8qXFxuICAgKiBUeXBvZ3JhcGh5XFxuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4gIC0tZm9udC1mYW1pbHktYmFzZTogJ1NlZ29lIFVJJywgJ0hlbHZldGljYU5ldWUtTGlnaHQnLCBzYW5zLXNlcmlmO1xcblxcbiAgLypcXG4gICAqIExheW91dFxcbiAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuICAtLW1heC1jb250ZW50LXdpZHRoOiAxMDAwcHg7XFxuXFxuICAvKlxcbiAgICogQXBwbGljYXRpb24gc3BlY2lmaWNcXG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbiAgLS1oZWRnZWhvZy1ncmVlbi1saWdodDogIzM4YjQ0OTtcXG4gIC0taGVkZ2Vob2ctZ3JlZW4tZGFyazogIzAwN2MzYztcXG5cXG4gIC8qXFxuICAgKiBNZWRpYSBxdWVyaWVzIGJyZWFrcG9pbnRzXFxuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4gIC0tc2NyZWVuLXhzLW1pbjogNDgwcHg7ICAvKiBFeHRyYSBzbWFsbCBzY3JlZW4gLyBwaG9uZSAqL1xcbiAgLS1zY3JlZW4tc20tbWluOiA3NjhweDsgIC8qIFNtYWxsIHNjcmVlbiAvIHRhYmxldCAqL1xcbiAgLS1zY3JlZW4tbWQtbWluOiA5OTJweDsgIC8qIE1lZGl1bSBzY3JlZW4gLyBkZXNrdG9wICovXFxuICAtLXNjcmVlbi1sZy1taW46IDEyMDBweDsgLyogTGFyZ2Ugc2NyZWVuIC8gd2lkZSBkZXNrdG9wICovXFxufVxcblxcbi5XZWJSVEMtcm9vdC0xUWtIOCB7XFxuICBwYWRkaW5nLWxlZnQ6IDIwcHg7XFxuICBwYWRkaW5nLXJpZ2h0OiAyMHB4O1xcbn1cXG5cXG4uV2ViUlRDLWNvbnRhaW5lci0xTkZNUCB7XFxuICBtYXJnaW46IDAgYXV0bztcXG4gIHBhZGRpbmc6IDAgMCA0MHB4O1xcbiAgbWF4LXdpZHRoOiAxMDAwcHg7XFxuICBtYXgtd2lkdGg6IHZhcigtLW1heC1jb250ZW50LXdpZHRoKTtcXG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIC1tcy1mbGV4LWZsb3c6IHJvdyBub3dyYXA7XFxuICAgICAgZmxleC1mbG93OiByb3cgbm93cmFwO1xcbn1cXG5cXG4uV2ViUlRDLWNoYXQtdFYxQ2sge1xcbiAgLW1zLWZsZXg6IDEgMDtcXG4gICAgICBmbGV4OiAxIDA7XFxuICBtYXJnaW46IDEwcHg7XFxuICBwYWRkaW5nOiAwIDVweCA1cHhcXG59XFxuXFxuLldlYlJUQy1jaGF0LXRWMUNrIC5XZWJSVEMtbXNnLTNDT19JIHtcXG4gICAgbWFyZ2luOiA1cHggMDtcXG4gICAgcGFkZGluZzogNXB4XFxuICB9XFxuXFxuLldlYlJUQy1jaGF0LXRWMUNrIC5XZWJSVEMtbXNnLTNDT19JLldlYlJUQy1taW5lLTFteWlsIHtcXG4gICAgICBtYXJnaW4tbGVmdDogNGNtO1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNkZGQ7XFxuICAgIH1cXG5cXG4uV2ViUlRDLWNoYXQtdFYxQ2sgLldlYlJUQy1tc2ctM0NPX0kuV2ViUlRDLXRoZWlycy0zWFp0ZCB7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA0Y207XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzk1ZjtcXG4gICAgICBjb2xvcjogd2hpdGU7XFxuICAgIH1cXG5cXG4uV2ViUlRDLWVkaXRvci0xOEZwTiB7XFxuICAtbXMtZmxleDogMSAwO1xcbiAgICAgIGZsZXg6IDEgMDtcXG4gIG1hcmdpbjogMTBweDtcXG4gIHBhZGRpbmc6IDVweFxcbn1cXG5cXG4uV2ViUlRDLWVkaXRvci0xOEZwTiAuV2ViUlRDLWVkaXRvci13cmFwcGVyLTVmQ2lBIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBoZWlnaHQ6IDMwMHB4O1xcbiAgfVxcblxcbi5XZWJSVEMtcmVtb3RlLWN1cnNvci0xX0NTciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiA0O1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIGJvcmRlci1sZWZ0OiAycHggc29saWQgI2NjMDAwMDtcXG59XFxuXFxuLldlYlJUQy1yZW1vdGUtc2VsZWN0aW9uLTFKanpZIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZjc3ODg7XFxuICB6LWluZGV4OiAzO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2hvbWUvc2FyYWgvRG9jdW1lbnRzL0FyYmVpdC9naXRodWIvbmV0Um9iL05ldHJvYi9zcmMvcm91dGVzL3dlYnJ0Yy9XZWJSVEMuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7Ozs7OztHQU9HOztBQUVIOzs7Ozs7O0dBT0c7O0FBRUg7RUFDRTs7Z0ZBRThFOztFQUU5RSxrRUFBa0U7O0VBRWxFOztnRkFFOEU7O0VBRTlFLDRCQUE0Qjs7RUFFNUI7O2dGQUU4RTs7RUFFOUUsZ0NBQWdDO0VBQ2hDLCtCQUErQjs7RUFFL0I7O2dGQUU4RTs7RUFFOUUsdUJBQXVCLEVBQUUsZ0NBQWdDO0VBQ3pELHVCQUF1QixFQUFFLDJCQUEyQjtFQUNwRCx1QkFBdUIsRUFBRSw2QkFBNkI7RUFDdEQsd0JBQXdCLENBQUMsaUNBQWlDO0NBQzNEOztBQUVEO0VBQ0UsbUJBQW1CO0VBQ25CLG9CQUFvQjtDQUNyQjs7QUFFRDtFQUNFLGVBQWU7RUFDZixrQkFBa0I7RUFDbEIsa0JBQWtCO0VBQ2xCLG9DQUFvQztFQUNwQyxxQkFBcUI7RUFDckIsY0FBYztFQUNkLDBCQUEwQjtNQUN0QixzQkFBc0I7Q0FDM0I7O0FBRUQ7RUFDRSxjQUFjO01BQ1YsVUFBVTtFQUNkLGFBQWE7RUFDYixrQkFBa0I7Q0FDbkI7O0FBRUQ7SUFDSSxjQUFjO0lBQ2QsWUFBWTtHQUNiOztBQUVIO01BQ00saUJBQWlCO01BQ2pCLHVCQUF1QjtLQUN4Qjs7QUFFTDtNQUNNLGtCQUFrQjtNQUNsQix1QkFBdUI7TUFDdkIsYUFBYTtLQUNkOztBQUVMO0VBQ0UsY0FBYztNQUNWLFVBQVU7RUFDZCxhQUFhO0VBQ2IsWUFBWTtDQUNiOztBQUVEO0lBQ0ksbUJBQW1CO0lBQ25CLGNBQWM7R0FDZjs7QUFFSDtFQUNFLG1CQUFtQjtFQUNuQixXQUFXO0VBQ1gsaUJBQWlCO0VBQ2pCLCtCQUErQjtDQUNoQzs7QUFFRDtFQUNFLG1CQUFtQjtFQUNuQiwwQkFBMEI7RUFDMUIsV0FBVztDQUNaXCIsXCJmaWxlXCI6XCJXZWJSVEMuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKipcXG4gKiBSZWFjdCBTdGFydGVyIEtpdCAoaHR0cHM6Ly93d3cucmVhY3RzdGFydGVya2l0LmNvbS8pXFxuICpcXG4gKiBDb3B5cmlnaHQgwqkgMjAxNC1wcmVzZW50IEtyaWFzb2Z0LCBMTEMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqL1xcblxcbi8qKlxcbiAqIFJlYWN0IFN0YXJ0ZXIgS2l0IChodHRwczovL3d3dy5yZWFjdHN0YXJ0ZXJraXQuY29tLylcXG4gKlxcbiAqIENvcHlyaWdodCDCqSAyMDE0LXByZXNlbnQgS3JpYXNvZnQsIExMQy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuOnJvb3Qge1xcbiAgLypcXG4gICAqIFR5cG9ncmFwaHlcXG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbiAgLS1mb250LWZhbWlseS1iYXNlOiAnU2Vnb2UgVUknLCAnSGVsdmV0aWNhTmV1ZS1MaWdodCcsIHNhbnMtc2VyaWY7XFxuXFxuICAvKlxcbiAgICogTGF5b3V0XFxuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4gIC0tbWF4LWNvbnRlbnQtd2lkdGg6IDEwMDBweDtcXG5cXG4gIC8qXFxuICAgKiBBcHBsaWNhdGlvbiBzcGVjaWZpY1xcbiAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuICAtLWhlZGdlaG9nLWdyZWVuLWxpZ2h0OiAjMzhiNDQ5O1xcbiAgLS1oZWRnZWhvZy1ncmVlbi1kYXJrOiAjMDA3YzNjO1xcblxcbiAgLypcXG4gICAqIE1lZGlhIHF1ZXJpZXMgYnJlYWtwb2ludHNcXG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbiAgLS1zY3JlZW4teHMtbWluOiA0ODBweDsgIC8qIEV4dHJhIHNtYWxsIHNjcmVlbiAvIHBob25lICovXFxuICAtLXNjcmVlbi1zbS1taW46IDc2OHB4OyAgLyogU21hbGwgc2NyZWVuIC8gdGFibGV0ICovXFxuICAtLXNjcmVlbi1tZC1taW46IDk5MnB4OyAgLyogTWVkaXVtIHNjcmVlbiAvIGRlc2t0b3AgKi9cXG4gIC0tc2NyZWVuLWxnLW1pbjogMTIwMHB4OyAvKiBMYXJnZSBzY3JlZW4gLyB3aWRlIGRlc2t0b3AgKi9cXG59XFxuXFxuLnJvb3Qge1xcbiAgcGFkZGluZy1sZWZ0OiAyMHB4O1xcbiAgcGFkZGluZy1yaWdodDogMjBweDtcXG59XFxuXFxuLmNvbnRhaW5lciB7XFxuICBtYXJnaW46IDAgYXV0bztcXG4gIHBhZGRpbmc6IDAgMCA0MHB4O1xcbiAgbWF4LXdpZHRoOiAxMDAwcHg7XFxuICBtYXgtd2lkdGg6IHZhcigtLW1heC1jb250ZW50LXdpZHRoKTtcXG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIC1tcy1mbGV4LWZsb3c6IHJvdyBub3dyYXA7XFxuICAgICAgZmxleC1mbG93OiByb3cgbm93cmFwO1xcbn1cXG5cXG4uY2hhdCB7XFxuICAtbXMtZmxleDogMSAwO1xcbiAgICAgIGZsZXg6IDEgMDtcXG4gIG1hcmdpbjogMTBweDtcXG4gIHBhZGRpbmc6IDAgNXB4IDVweFxcbn1cXG5cXG4uY2hhdCAubXNnIHtcXG4gICAgbWFyZ2luOiA1cHggMDtcXG4gICAgcGFkZGluZzogNXB4XFxuICB9XFxuXFxuLmNoYXQgLm1zZy5taW5lIHtcXG4gICAgICBtYXJnaW4tbGVmdDogNGNtO1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNkZGQ7XFxuICAgIH1cXG5cXG4uY2hhdCAubXNnLnRoZWlycyB7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA0Y207XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzk1ZjtcXG4gICAgICBjb2xvcjogd2hpdGU7XFxuICAgIH1cXG5cXG4uZWRpdG9yIHtcXG4gIC1tcy1mbGV4OiAxIDA7XFxuICAgICAgZmxleDogMSAwO1xcbiAgbWFyZ2luOiAxMHB4O1xcbiAgcGFkZGluZzogNXB4XFxufVxcblxcbi5lZGl0b3IgLmVkaXRvci13cmFwcGVyIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBoZWlnaHQ6IDMwMHB4O1xcbiAgfVxcblxcbi5yZW1vdGUtY3Vyc29yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDQ7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWxlZnQ6IDJweCBzb2xpZCAjY2MwMDAwO1xcbn1cXG5cXG4ucmVtb3RlLXNlbGVjdGlvbiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmY3Nzg4O1xcbiAgei1pbmRleDogMztcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInJvb3RcIjogXCJXZWJSVEMtcm9vdC0xUWtIOFwiLFxuXHRcImNvbnRhaW5lclwiOiBcIldlYlJUQy1jb250YWluZXItMU5GTVBcIixcblx0XCJjaGF0XCI6IFwiV2ViUlRDLWNoYXQtdFYxQ2tcIixcblx0XCJtc2dcIjogXCJXZWJSVEMtbXNnLTNDT19JXCIsXG5cdFwibWluZVwiOiBcIldlYlJUQy1taW5lLTFteWlsXCIsXG5cdFwidGhlaXJzXCI6IFwiV2ViUlRDLXRoZWlycy0zWFp0ZFwiLFxuXHRcImVkaXRvclwiOiBcIldlYlJUQy1lZGl0b3ItMThGcE5cIixcblx0XCJlZGl0b3Itd3JhcHBlclwiOiBcIldlYlJUQy1lZGl0b3Itd3JhcHBlci01ZkNpQVwiLFxuXHRcInJlbW90ZS1jdXJzb3JcIjogXCJXZWJSVEMtcmVtb3RlLWN1cnNvci0xX0NTclwiLFxuXHRcInJlbW90ZS1zZWxlY3Rpb25cIjogXCJXZWJSVEMtcmVtb3RlLXNlbGVjdGlvbi0xSmp6WVwiXG59OyIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEFjZUVkaXRvciBmcm9tICdyZWFjdC1hY2UnO1xuXG5pbXBvcnQgdHlwZSB7IEFjZVJlZiwgQWNlQ29uZmlnIH0gZnJvbSAnLi9hY2VUeXBlcyc7XG5pbXBvcnQgdXNlQ29uY2xhdmUsIHsgdHlwZSBDb25uZWN0aW9uQ29uZmlnIH0gZnJvbSAnLi91c2VDb25jbGF2ZSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjc3MtbW9kdWxlcy9uby11bnVzZWQtY2xhc3NcbmltcG9ydCBzIGZyb20gJy4vV2ViUlRDLnNjc3MnO1xuXG5leHBvcnQgdHlwZSB7IENvbm5lY3Rpb25Db25maWcgfTtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNvbm5lY3Rpb25Db25maWc6IENvbm5lY3Rpb25Db25maWcsXG4gIC4uLkFjZUNvbmZpZyxcbnx9O1xudHlwZSBJbnN0YW5jZSA9IEFjZVJlZjtcblxuY29uc3QgQWNlUGVlckVkaXRvciA9IFJlYWN0LmZvcndhcmRSZWY8UHJvcHMsIEluc3RhbmNlPihcbiAgKHsgY29ubmVjdGlvbkNvbmZpZywgLi4ucHJvcHMgfTogUHJvcHMsIHJlZjogP1JlZjxJbnN0YW5jZT4pID0+IHtcbiAgICBmdW5jdGlvbiBnZXRNYXJrZXJDbGFzc05hbWUoX3NpdGVJZDogc3RyaW5nLCB0eXBlOiAnc2VsZWN0aW9uJyB8ICdjdXJzb3InKSB7XG4gICAgICByZXR1cm4gc1tgcmVtb3RlLSR7dHlwZX1gXTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25jbGF2ZSA9IHVzZUNvbmNsYXZlKGNvbm5lY3Rpb25Db25maWcsIGdldE1hcmtlckNsYXNzTmFtZSk7XG5cbiAgICByZXR1cm4gPEFjZUVkaXRvciByZWY9e3JlZn0gey4uLmNvbmNsYXZlLm1vdW50QWNlRWRpdG9yKHByb3BzKX0gLz47XG4gIH0sXG4pO1xuXG5leHBvcnQgdHlwZSBBY2VQZWVyRWRpdG9yVHlwZSA9IFJlYWN0LkVsZW1lbnRSZWY8dHlwZW9mIEFjZVBlZXJFZGl0b3I+O1xuZXhwb3J0IGRlZmF1bHQgQWNlUGVlckVkaXRvcjtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTdHlsZXMgZnJvbSAnaXNvbW9ycGhpYy1zdHlsZS1sb2FkZXIvdXNlU3R5bGVzJztcblxuaW1wb3J0IFBhcGVyIGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL1BhcGVyJztcblxuaW1wb3J0IFBlZXIsIHsgRGF0YUNvbm5lY3Rpb24gfSBmcm9tICdwZWVyanMnO1xuXG5pbXBvcnQgJ3JlYWN0LWFjZSc7XG5pbXBvcnQgJ2FjZS1idWlsZHMvd2VicGFjay1yZXNvbHZlcic7XG5pbXBvcnQgJ2FjZS1idWlsZHMvc3JjLW5vY29uZmxpY3QvbW9kZS1qYXZhc2NyaXB0JztcbmltcG9ydCAnYWNlLWJ1aWxkcy9zcmMtbm9jb25mbGljdC9leHQtbGFuZ3VhZ2VfdG9vbHMnO1xuaW1wb3J0ICdhY2UtYnVpbGRzL3NyYy1ub2NvbmZsaWN0L3RoZW1lLWdpdGh1Yic7XG5cbmltcG9ydCBBY2VQZWVyRWRpdG9yLCB7IHR5cGUgQ29ubmVjdGlvbkNvbmZpZyB9IGZyb20gJy4vQWNlUGVlckVkaXRvcic7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjc3MtbW9kdWxlcy9uby11bnVzZWQtY2xhc3NcbmltcG9ydCBzIGZyb20gJy4vV2ViUlRDLnNjc3MnO1xuXG5jb25zdCBwZWVyT3B0aW9ucyA9IF9fREVWX19cbiAgPyB7XG4gICAgICBob3N0OiAnbG9jYWxob3N0JyxcbiAgICAgIHBvcnQ6IDMwMTAsXG4gICAgICBwYXRoOiAnL3BlZXJqcycsXG4gICAgfVxuICA6IHtcbiAgICAgIGhvc3Q6ICcvJyxcbiAgICAgIHBhdGg6ICcvcGVlcmpzJyxcbiAgICB9O1xuXG50eXBlIE1lc3NhZ2UgPSB7fFxuICB0eXBlOiAnSU4nIHwgJ09VVCcsXG4gIHRleHQ6IHN0cmluZyxcbnx9O1xuXG5mdW5jdGlvbiBtc2codHlwZTogJ0lOJyB8ICdPVVQnLCB0ZXh0OiBzdHJpbmcpOiBNZXNzYWdlIHtcbiAgcmV0dXJuIHsgdHlwZSwgdGV4dCB9O1xufVxuXG50eXBlIENoYXRQcm9wcyA9IHt8XG4gIGNvbm5lY3Rpb246IERhdGFDb25uZWN0aW9uIHwgbnVsbCxcbiAgc2VuZFRleHQ6IHN0cmluZyxcbnx9O1xuXG5mdW5jdGlvbiBDaGF0KHsgY29ubmVjdGlvbiwgc2VuZFRleHQgfTogQ2hhdFByb3BzKSB7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gUmVhY3QudXNlU3RhdGU8TWVzc2FnZVtdPihbXSk7XG5cbiAgZnVuY3Rpb24gaGFuZGxlU2VuZCgpIHtcbiAgICBpZiAoY29ubmVjdGlvbiA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgc2V0TWVzc2FnZXMoKG9sZE1lc3NhZ2VzKSA9PiBbLi4ub2xkTWVzc2FnZXMsIG1zZygnT1VUJywgc2VuZFRleHQpXSk7XG4gICAgY29ubmVjdGlvbi5zZW5kKHNlbmRUZXh0KTtcbiAgfVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNvbm5lY3Rpb24gPT09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVSZWN2KHRleHQpIHtcbiAgICAgIHNldE1lc3NhZ2VzKChvbGRNZXNzYWdlcykgPT4gWy4uLm9sZE1lc3NhZ2VzLCBtc2coJ0lOJywgdGV4dCldKTtcbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLm9uKCdkYXRhJywgaGFuZGxlUmVjdik7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29ubmVjdGlvbi5vZmYoJ2RhdGEnLCBoYW5kbGVSZWN2KTtcbiAgICB9O1xuICB9LCBbY29ubmVjdGlvbl0pO1xuXG4gIHJldHVybiAoXG4gICAgPFBhcGVyIGNsYXNzTmFtZT17cy5jaGF0fSBzcXVhcmU+XG4gICAgICB7bWVzc2FnZXMubWFwKCh7IHR5cGUsIHRleHQgfSwgaW5kZXgpID0+IChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICA8ZGl2IGtleT17aW5kZXh9IGNsYXNzTmFtZT17YCR7cy5tc2d9ICR7dHlwZSA9PT0gJ09VVCcgPyBzLm1pbmUgOiBzLnRoZWlyc31gfT5cbiAgICAgICAgICB7dGV4dH1cbiAgICAgICAgPC9kaXY+XG4gICAgICApKX1cbiAgICAgIDxkaXY+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9e2hhbmRsZVNlbmR9PlxuICAgICAgICAgIFNlbmRcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIENvbm5lY3RlZDoge2Nvbm5lY3Rpb24gIT09IG51bGwgPyAneWVzJyA6ICdubyd9XG4gICAgICA8L2Rpdj5cbiAgICA8L1BhcGVyPlxuICApO1xufVxuXG50eXBlIEVkaXRvclByb3BzID0ge3xcbiAgY29ubmVjdGlvbkNvbmZpZzogQ29ubmVjdGlvbkNvbmZpZyxcbnx9O1xuXG5mdW5jdGlvbiBFZGl0b3IoeyBjb25uZWN0aW9uQ29uZmlnIH06IEVkaXRvclByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPFBhcGVyIGNsYXNzTmFtZT17cy5lZGl0b3J9IHNxdWFyZT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzWydlZGl0b3Itd3JhcHBlciddfT5cbiAgICAgICAgPEFjZVBlZXJFZGl0b3JcbiAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnPXt7IHBlZXJPcHRpb25zLCAuLi5jb25uZWN0aW9uQ29uZmlnIH19XG4gICAgICAgICAgbW9kZT1cImphdmFzY3JpcHRcIlxuICAgICAgICAgIHRoZW1lPVwiZ2l0aHViXCJcbiAgICAgICAgICBuYW1lPVwiZWRpdG9yXCJcbiAgICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICAgIGhlaWdodD1cIjEwMCVcIlxuICAgICAgICAgIGZvbnRTaXplPXsxNn1cbiAgICAgICAgICBzaG93R3V0dGVyXG4gICAgICAgICAgaGlnaGxpZ2h0QWN0aXZlTGluZVxuICAgICAgICAgIGF1dG9TY3JvbGxFZGl0b3JJbnRvVmlld1xuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB9fVxuICAgICAgICAgIHNldE9wdGlvbnM9e3tcbiAgICAgICAgICAgIGVuYWJsZUJhc2ljQXV0b2NvbXBsZXRpb246IHRydWUsXG4gICAgICAgICAgICBlbmFibGVMaXZlQXV0b2NvbXBsZXRpb246IHRydWUsXG4gICAgICAgICAgICAvLyBlbmFibGVTbmlwcGV0czogZW5hYmxlU25pcHBldHMsXG4gICAgICAgICAgICBzaG93TGluZU51bWJlcnM6IHRydWUsXG4gICAgICAgICAgICB0YWJTaXplOiAyLFxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L1BhcGVyPlxuICApO1xufVxuXG50eXBlIFByb3BzID0ge3x8fTtcblxuZnVuY3Rpb24gV2ViUlRDKF9wcm9wczogUHJvcHMpIHtcbiAgY29uc3QgW2xlZnQsIHNldExlZnRdID0gUmVhY3QudXNlU3RhdGU8RGF0YUNvbm5lY3Rpb24gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3JpZ2h0LCBzZXRSaWdodF0gPSBSZWFjdC51c2VTdGF0ZTxEYXRhQ29ubmVjdGlvbiB8IG51bGw+KG51bGwpO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZygnb3B0aW9uczonLCBwZWVyT3B0aW9ucyk7XG4gICAgICBjb25zdCBsZWZ0UGVlciA9IG5ldyBQZWVyKHBlZXJPcHRpb25zKTtcbiAgICAgIGNvbnN0IHJpZ2h0UGVlciA9IG5ldyBQZWVyKHBlZXJPcHRpb25zKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZygncGVlcnMgY3JlYXRlZCcpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGxlZnRQZWVyLm9uKCdlcnJvcicsIChlcnIpID0+IGNvbnNvbGUubG9nKGVycikpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIHJpZ2h0UGVlci5vbignZXJyb3InLCAoZXJyKSA9PiBjb25zb2xlLmxvZyhlcnIpKTtcblxuICAgICAgY29uc3QgbGVmdElkID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IGxlZnRQZWVyLm9uKCdvcGVuJywgcmVzb2x2ZSkpO1xuICAgICAgY29uc3QgcmlnaHRJZCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByaWdodFBlZXIub24oJ29wZW4nLCByZXNvbHZlKSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5sb2cobGVmdElkLCByaWdodElkKTtcbiAgICAgIGNvbnN0IHJpZ2h0Q29ubiA9IHJpZ2h0UGVlci5jb25uZWN0KGxlZnRJZCk7XG4gICAgICBjb25zdCBsZWZ0Q29ubiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBsZWZ0UGVlci5vbignY29ubmVjdGlvbicsIHJlc29sdmUpKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZygncGVlcnMgY29ubmVjdGVkJyk7XG5cbiAgICAgIHNldExlZnQobGVmdENvbm4pO1xuICAgICAgc2V0UmlnaHQocmlnaHRDb25uKTtcbiAgICB9KSgpO1xuICB9LCBbXSk7XG5cbiAgdXNlU3R5bGVzKHMpO1xuXG4gIGNvbnN0IFtsZWZ0UGVlcklkLCBzZXRMZWZ0UGVlcklkXSA9IFJlYWN0LnVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3Mucm9vdH0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17cy5jb250YWluZXJ9PlxuICAgICAgICA8Q2hhdCBjb25uZWN0aW9uPXtsZWZ0fSBzZW5kVGV4dD1cIkhlbGxvXCIgLz5cbiAgICAgICAgPENoYXQgY29ubmVjdGlvbj17cmlnaHR9IHNlbmRUZXh0PVwiVGhlcmVcIiAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17cy5jb250YWluZXJ9PlxuICAgICAgICA8RWRpdG9yXG4gICAgICAgICAgY29ubmVjdGlvbkNvbmZpZz17e1xuICAgICAgICAgICAgc2l0ZUlkOiAnbGVmdCcsXG4gICAgICAgICAgICB0YXJnZXRQZWVySWQ6IG51bGwsXG4gICAgICAgICAgICBvbk9wZW46IHNldExlZnRQZWVySWQsXG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgICAge2xlZnRQZWVySWQgJiYgKFxuICAgICAgICAgIDxFZGl0b3JcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Db25maWc9e3tcbiAgICAgICAgICAgICAgc2l0ZUlkOiAncmlnaHQnLFxuICAgICAgICAgICAgICB0YXJnZXRQZWVySWQ6IGxlZnRQZWVySWQsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgV2ViUlRDO1xuIiwiXG4gICAgdmFyIHJlZnMgPSAwO1xuICAgIHZhciBjc3MgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS03LXJ1bGVzLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS03LXJ1bGVzLTMhLi9XZWJSVEMuc2Nzc1wiKTtcbiAgICB2YXIgaW5zZXJ0Q3NzID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvaXNvbW9ycGhpYy1zdHlsZS1sb2FkZXIvaW5zZXJ0Q3NzLmpzXCIpO1xuICAgIHZhciBjb250ZW50ID0gdHlwZW9mIGNzcyA9PT0gJ3N0cmluZycgPyBbW21vZHVsZS5pZCwgY3NzLCAnJ11dIDogY3NzO1xuXG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3NzLmxvY2FscyB8fCB7fTtcbiAgICBleHBvcnRzLl9nZXRDb250ZW50ID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb250ZW50OyB9O1xuICAgIGV4cG9ydHMuX2dldENzcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJycgKyBjc3M7IH07XG4gICAgZXhwb3J0cy5faW5zZXJ0Q3NzID0gZnVuY3Rpb24ob3B0aW9ucykgeyByZXR1cm4gaW5zZXJ0Q3NzKGNvbnRlbnQsIG9wdGlvbnMpIH07XG5cbiAgICAvLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG4gICAgLy8gaHR0cHM6Ly93ZWJwYWNrLmdpdGh1Yi5pby9kb2NzL2hvdC1tb2R1bGUtcmVwbGFjZW1lbnRcbiAgICAvLyBPbmx5IGFjdGl2YXRlZCBpbiBicm93c2VyIGNvbnRleHRcbiAgICBpZiAobW9kdWxlLmhvdCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgIHZhciByZW1vdmVDc3MgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTctcnVsZXMtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTctcnVsZXMtMyEuL1dlYlJUQy5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjc3MgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS03LXJ1bGVzLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS03LXJ1bGVzLTMhLi9XZWJSVEMuc2Nzc1wiKTtcbiAgICAgICAgY29udGVudCA9IHR5cGVvZiBjc3MgPT09ICdzdHJpbmcnID8gW1ttb2R1bGUuaWQsIGNzcywgJyddXSA6IGNzcztcbiAgICAgICAgcmVtb3ZlQ3NzID0gaW5zZXJ0Q3NzKGNvbnRlbnQsIHsgcmVwbGFjZTogdHJ1ZSB9KTtcbiAgICAgIH0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyByZW1vdmVDc3MoKTsgfSk7XG4gICAgfVxuICAiLCIvLyBAZmxvd1xuXG5pbXBvcnQgUGVlciBmcm9tICdwZWVyanMnO1xuXG5pbXBvcnQgQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXInO1xuaW1wb3J0IENoYXIgZnJvbSAnLi9jaGFyJztcbmltcG9ydCB7IHR5cGUgVmVyc2lvbkRhdGEgfSBmcm9tICcuL3ZlcnNpb24nO1xuXG50eXBlIERhdGFDb25uZWN0aW9uID0gUGVlci5EYXRhQ29ubmVjdGlvbjtcblxuZXhwb3J0IHR5cGUgU3luY09wZXJhdGlvbiA9IHt8XG4gIHR5cGU6ICdzeW5jUmVzcG9uc2UnLFxuICBzaXRlSWQ6IHN0cmluZyxcbiAgcGVlcklkOiBzdHJpbmcsXG4gIGluaXRpYWxTdHJ1Y3Q6IGFueSxcbiAgaW5pdGlhbFZlcnNpb25zOiBhbnksXG4gIG5ldHdvcms6IGFueSxcbnx9O1xuXG5leHBvcnQgdHlwZSBFZGl0T3BlcmF0aW9uID1cbiAgfCB7fCB0eXBlOiAnaW5zZXJ0JywgY2hhcjogQ2hhciwgdmVyc2lvbjogVmVyc2lvbkRhdGEgfH1cbiAgfCB7fCB0eXBlOiAnZGVsZXRlJywgY2hhcjogQ2hhciwgdmVyc2lvbjogVmVyc2lvbkRhdGEgfH07XG5cbmV4cG9ydCB0eXBlIE9wZXJhdGlvbiA9XG4gIHwgRWRpdE9wZXJhdGlvblxuICB8IHt8IHR5cGU6ICdhZGQgdG8gbmV0d29yaycsIG5ld1BlZXI6IHN0cmluZywgbmV3U2l0ZTogc3RyaW5nIHx9XG4gIHwge3wgdHlwZTogJ3JlbW92ZSBmcm9tIG5ldHdvcmsnLCBvbGRQZWVyOiBzdHJpbmcgfH1cbiAgfCB7fCB0eXBlOiAnY29ublJlcXVlc3QnLCBwZWVySWQ6IHN0cmluZywgc2l0ZUlkOiBzdHJpbmcgfH1cbiAgfCBTeW5jT3BlcmF0aW9uXG4gIHwge3wgdHlwZTogJ3N5bmNDb21wbGV0ZWQnLCBwZWVySWQ6IHN0cmluZyB8fTtcblxudHlwZSBIZWFydGJlYXQgPSB7fFxuICBzdGFydCgpOiB2b2lkLFxuICBzdG9wKCk6IHZvaWQsXG58fTtcblxuY2xhc3MgQnJvYWRjYXN0IHtcbiAgY29udHJvbGxlcjogQ29udHJvbGxlcjtcbiAgcGVlcjogUGVlcjtcbiAgb3V0Q29ubnM6IERhdGFDb25uZWN0aW9uW107XG4gIGluQ29ubnM6IERhdGFDb25uZWN0aW9uW107XG4gIG91dGdvaW5nQnVmZmVyOiBzdHJpbmdbXTtcbiAgTUFYX0JVRkZFUl9TSVpFOiBudW1iZXI7XG4gIGhlYXJ0YmVhdDogSGVhcnRiZWF0O1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRyb2xsZXI6IENvbnRyb2xsZXIsIHBlZXI6IFBlZXIsIHRhcmdldFBlZXJJZDogc3RyaW5nIHwgbnVsbCkge1xuICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgdGhpcy5wZWVyID0gcGVlcjtcbiAgICB0aGlzLm91dENvbm5zID0gW107XG4gICAgdGhpcy5pbkNvbm5zID0gW107XG4gICAgdGhpcy5vdXRnb2luZ0J1ZmZlciA9IFtdO1xuICAgIHRoaXMuTUFYX0JVRkZFUl9TSVpFID0gNDA7XG5cbiAgICB0aGlzLmhlYXJ0YmVhdCA9IHRoaXMuc3RhcnRQZWVySGVhcnRCZWF0KHBlZXIpO1xuICAgIHRoaXMub25PcGVuKHRhcmdldFBlZXJJZCk7XG4gIH1cblxuICBzZW5kKG9wZXJhdGlvbjogT3BlcmF0aW9uKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uSlNPTiA9IEpTT04uc3RyaW5naWZ5KG9wZXJhdGlvbik7XG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSAnaW5zZXJ0JyB8fCBvcGVyYXRpb24udHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgIHRoaXMuYWRkVG9PdXRnb2luZ0J1ZmZlcihvcGVyYXRpb25KU09OKTtcbiAgICB9XG4gICAgdGhpcy5vdXRDb25ucy5mb3JFYWNoKGNvbm4gPT4gY29ubi5zZW5kKG9wZXJhdGlvbkpTT04pKTtcbiAgfVxuXG4gIGFkZFRvT3V0Z29pbmdCdWZmZXIob3BlcmF0aW9uSlNPTjogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMub3V0Z29pbmdCdWZmZXIubGVuZ3RoID09PSB0aGlzLk1BWF9CVUZGRVJfU0laRSkge1xuICAgICAgdGhpcy5vdXRnb2luZ0J1ZmZlci5zaGlmdCgpO1xuICAgIH1cblxuICAgIHRoaXMub3V0Z29pbmdCdWZmZXIucHVzaChvcGVyYXRpb25KU09OKTtcbiAgfVxuXG4gIHByb2Nlc3NPdXRnb2luZ0J1ZmZlcihwZWVySWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGNvbm5lY3Rpb246IERhdGFDb25uZWN0aW9uID0gdGhpcy5vdXRDb25ucy5maW5kKGNvbm4gPT4gY29ubi5wZWVyID09PSBwZWVySWQpO1xuICAgIHRoaXMub3V0Z29pbmdCdWZmZXIuZm9yRWFjaChvcCA9PiB7XG4gICAgICBjb25uZWN0aW9uLnNlbmQob3ApO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhcnRQZWVySGVhcnRCZWF0KHBlZXI6IFBlZXIpOiBIZWFydGJlYXQge1xuICAgIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICAgIGNvbnN0IGhlYXJ0YmVhdCA9ICgpID0+IHtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoaGVhcnRiZWF0LCAyMDAwMCk7XG4gICAgICBpZiAocGVlci5zb2NrZXQuX3dzT3BlbigpKSB7XG4gICAgICAgIHBlZXIuc29ja2V0LnNlbmQoeyB0eXBlOiAnSEVBUlRCRUFUJyB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaGVhcnRiZWF0KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQgPT09IG51bGwpIHtcbiAgICAgICAgICBoZWFydGJlYXQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0b3AoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgb25PcGVuKHRhcmdldFBlZXJJZDogc3RyaW5nIHwgbnVsbCkge1xuICAgIHRoaXMucGVlci5vbignb3BlbicsIGlkID0+IHtcbiAgICAgIHRoaXMub25QZWVyQ29ubmVjdGlvbigpO1xuICAgICAgdGhpcy5vbkVycm9yKCk7XG4gICAgICB0aGlzLm9uRGlzY29ubmVjdCgpO1xuICAgICAgaWYgKHRhcmdldFBlZXJJZCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWRkVG9OZXR3b3JrKGlkLCB0aGlzLmNvbnRyb2xsZXIuc2l0ZUlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVxdWVzdENvbm5lY3Rpb24odGFyZ2V0UGVlcklkLCBpZCwgdGhpcy5jb250cm9sbGVyLnNpdGVJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBvbkVycm9yKCkge1xuICAgIHRoaXMucGVlci5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgY29uc3QgcGlkID0gU3RyaW5nKGVycikucmVwbGFjZSgnRXJyb3I6IENvdWxkIG5vdCBjb25uZWN0IHRvIHBlZXIgJywgJycpO1xuICAgICAgdGhpcy5yZW1vdmVGcm9tQ29ubmVjdGlvbnMocGlkKTtcbiAgICAgIGNvbnNvbGUubG9nKGVyci50eXBlKTtcbiAgICAgIGlmICghdGhpcy5wZWVyLmRpc2Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuZmluZE5ld1RhcmdldCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgb25EaXNjb25uZWN0KCkge1xuICAgIHRoaXMucGVlci5vbignZGlzY29ubmVjdGVkJywgKCkgPT4ge1xuICAgICAgdGhpcy5jb250cm9sbGVyLmxvc3RDb25uZWN0aW9uKCk7XG4gICAgfSk7XG4gIH1cblxuICByZXF1ZXN0Q29ubmVjdGlvbih0YXJnZXQ6IHN0cmluZywgcGVlcklkOiBzdHJpbmcsIHNpdGVJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgY29ubiA9IHRoaXMucGVlci5jb25uZWN0KHRhcmdldCk7XG4gICAgdGhpcy5hZGRUb091dENvbm5zKGNvbm4pO1xuICAgIGNvbm4ub24oJ29wZW4nLCAoKSA9PiB7XG4gICAgICBjb25uLnNlbmQoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB0eXBlOiAnY29ublJlcXVlc3QnLFxuICAgICAgICAgIHBlZXJJZCxcbiAgICAgICAgICBzaXRlSWQsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIGV2YWx1YXRlUmVxdWVzdChwZWVySWQ6IHN0cmluZywgc2l0ZUlkOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5oYXNSZWFjaGVkTWF4KCkpIHtcbiAgICAgIHRoaXMuZm9yd2FyZENvbm5SZXF1ZXN0KHBlZXJJZCwgc2l0ZUlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hY2NlcHRDb25uUmVxdWVzdChwZWVySWQsIHNpdGVJZCk7XG4gICAgfVxuICB9XG5cbiAgaGFzUmVhY2hlZE1heCgpOiBib29sZWFuIHtcbiAgICBjb25zdCBoYWxmVGhlTmV0d29yayA9IE1hdGguY2VpbCh0aGlzLmNvbnRyb2xsZXIubmV0d29yay5sZW5ndGggLyAyKTtcbiAgICBjb25zdCB0b29NYW55SW5Db25ucyA9IHRoaXMuaW5Db25ucy5sZW5ndGggPiBNYXRoLm1heChoYWxmVGhlTmV0d29yaywgNSk7XG4gICAgY29uc3QgdG9vTWFueU91dENvbm5zID0gdGhpcy5vdXRDb25ucy5sZW5ndGggPiBNYXRoLm1heChoYWxmVGhlTmV0d29yaywgNSk7XG5cbiAgICByZXR1cm4gdG9vTWFueUluQ29ubnMgfHwgdG9vTWFueU91dENvbm5zO1xuICB9XG5cbiAgZm9yd2FyZENvbm5SZXF1ZXN0KHBlZXJJZDogc3RyaW5nLCBzaXRlSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGNvbm5lY3RlZCA9IHRoaXMub3V0Q29ubnMuZmlsdGVyKGNvbm4gPT4gY29ubi5wZWVyICE9PSBwZWVySWQpO1xuICAgIGNvbnN0IHJhbmRvbUlkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvbm5lY3RlZC5sZW5ndGgpO1xuICAgIGNvbm5lY3RlZFtyYW5kb21JZHhdLnNlbmQoXG4gICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHR5cGU6ICdjb25uUmVxdWVzdCcsXG4gICAgICAgIHBlZXJJZCxcbiAgICAgICAgc2l0ZUlkLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIGFkZFRvT3V0Q29ubnMoY29ubmVjdGlvbjogRGF0YUNvbm5lY3Rpb24pIHtcbiAgICBpZiAoISFjb25uZWN0aW9uICYmICF0aGlzLmlzQWxyZWFkeUNvbm5lY3RlZE91dChjb25uZWN0aW9uKSkge1xuICAgICAgdGhpcy5vdXRDb25ucy5wdXNoKGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGFkZFRvSW5Db25ucyhjb25uZWN0aW9uOiBEYXRhQ29ubmVjdGlvbikge1xuICAgIGlmICghIWNvbm5lY3Rpb24gJiYgIXRoaXMuaXNBbHJlYWR5Q29ubmVjdGVkSW4oY29ubmVjdGlvbikpIHtcbiAgICAgIHRoaXMuaW5Db25ucy5wdXNoKGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGFkZFRvTmV0d29yayhwZWVySWQ6IHN0cmluZywgc2l0ZUlkOiBzdHJpbmcpIHtcbiAgICB0aGlzLnNlbmQoe1xuICAgICAgdHlwZTogJ2FkZCB0byBuZXR3b3JrJyxcbiAgICAgIG5ld1BlZXI6IHBlZXJJZCxcbiAgICAgIG5ld1NpdGU6IHNpdGVJZCxcbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZUZyb21OZXR3b3JrKHBlZXJJZDogc3RyaW5nKSB7XG4gICAgdGhpcy5zZW5kKHtcbiAgICAgIHR5cGU6ICdyZW1vdmUgZnJvbSBuZXR3b3JrJyxcbiAgICAgIG9sZFBlZXI6IHBlZXJJZCxcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRyb2xsZXIucmVtb3ZlRnJvbU5ldHdvcmsocGVlcklkKTtcbiAgfVxuXG4gIHJlbW92ZUZyb21Db25uZWN0aW9ucyhwZWVyOiBzdHJpbmcpIHtcbiAgICB0aGlzLmluQ29ubnMgPSB0aGlzLmluQ29ubnMuZmlsdGVyKGNvbm4gPT4gY29ubi5wZWVyICE9PSBwZWVyKTtcbiAgICB0aGlzLm91dENvbm5zID0gdGhpcy5vdXRDb25ucy5maWx0ZXIoY29ubiA9PiBjb25uLnBlZXIgIT09IHBlZXIpO1xuICAgIHRoaXMucmVtb3ZlRnJvbU5ldHdvcmsocGVlcik7XG4gIH1cblxuICBpc0FscmVhZHlDb25uZWN0ZWRPdXQoY29ubmVjdGlvbjogRGF0YUNvbm5lY3Rpb24pIHtcbiAgICBpZiAoY29ubmVjdGlvbi5wZWVyKSB7XG4gICAgICByZXR1cm4gISF0aGlzLm91dENvbm5zLmZpbmQoY29ubiA9PiBjb25uLnBlZXIgPT09IGNvbm5lY3Rpb24ucGVlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAhIXRoaXMub3V0Q29ubnMuZmluZChjb25uID0+IGNvbm4ucGVlci5pZCA9PT0gY29ubmVjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgaXNBbHJlYWR5Q29ubmVjdGVkSW4oY29ubmVjdGlvbjogRGF0YUNvbm5lY3Rpb24pIHtcbiAgICBpZiAoY29ubmVjdGlvbi5wZWVyKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmluQ29ubnMuZmluZChjb25uID0+IGNvbm4ucGVlciA9PT0gY29ubmVjdGlvbi5wZWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICEhdGhpcy5pbkNvbm5zLmZpbmQoY29ubiA9PiBjb25uLnBlZXIuaWQgPT09IGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIG9uUGVlckNvbm5lY3Rpb24oKSB7XG4gICAgdGhpcy5wZWVyLm9uKCdjb25uZWN0aW9uJywgY29ubmVjdGlvbiA9PiB7XG4gICAgICB0aGlzLm9uQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgIHRoaXMub25EYXRhKGNvbm5lY3Rpb24pO1xuICAgICAgdGhpcy5vbkNvbm5DbG9zZShjb25uZWN0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFjY2VwdENvbm5SZXF1ZXN0KHBlZXJJZDogc3RyaW5nLCBzaXRlSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGNvbm5CYWNrID0gdGhpcy5wZWVyLmNvbm5lY3QocGVlcklkKTtcbiAgICB0aGlzLmFkZFRvT3V0Q29ubnMoY29ubkJhY2spO1xuICAgIHRoaXMuY29udHJvbGxlci5hZGRUb05ldHdvcmsocGVlcklkLCBzaXRlSWQpO1xuXG4gICAgY29uc3QgaW5pdGlhbERhdGEgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0eXBlOiAnc3luY1Jlc3BvbnNlJyxcbiAgICAgIHNpdGVJZDogdGhpcy5jb250cm9sbGVyLnNpdGVJZCxcbiAgICAgIHBlZXJJZDogdGhpcy5wZWVyLmlkLFxuICAgICAgaW5pdGlhbFN0cnVjdDogdGhpcy5jb250cm9sbGVyLmNyZHQuc3RydWN0LFxuICAgICAgaW5pdGlhbFZlcnNpb25zOiB0aGlzLmNvbnRyb2xsZXIudmVjdG9yLnZlcnNpb25zLFxuICAgICAgbmV0d29yazogdGhpcy5jb250cm9sbGVyLm5ldHdvcmssXG4gICAgfSk7XG5cbiAgICBpZiAoY29ubkJhY2sub3Blbikge1xuICAgICAgY29ubkJhY2suc2VuZChpbml0aWFsRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbm5CYWNrLm9uKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICBjb25uQmFjay5zZW5kKGluaXRpYWxEYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG9uQ29ubmVjdGlvbihjb25uZWN0aW9uOiBEYXRhQ29ubmVjdGlvbikge1xuICAgIHRoaXMuYWRkVG9JbkNvbm5zKGNvbm5lY3Rpb24pO1xuICB9XG5cbiAgb25EYXRhKGNvbm5lY3Rpb246IERhdGFDb25uZWN0aW9uKSB7XG4gICAgY29ubmVjdGlvbi5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgY29uc3QgZGF0YU9iajogT3BlcmF0aW9uID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgICAgc3dpdGNoIChkYXRhT2JqLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29ublJlcXVlc3QnOlxuICAgICAgICAgIHRoaXMuZXZhbHVhdGVSZXF1ZXN0KGRhdGFPYmoucGVlcklkLCBkYXRhT2JqLnNpdGVJZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N5bmNSZXNwb25zZSc6XG4gICAgICAgICAgdGhpcy5wcm9jZXNzT3V0Z29pbmdCdWZmZXIoZGF0YU9iai5wZWVySWQpO1xuICAgICAgICAgIHRoaXMuY29udHJvbGxlci5oYW5kbGVTeW5jKGRhdGFPYmopO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzeW5jQ29tcGxldGVkJzpcbiAgICAgICAgICB0aGlzLnByb2Nlc3NPdXRnb2luZ0J1ZmZlcihkYXRhT2JqLnBlZXJJZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FkZCB0byBuZXR3b3JrJzpcbiAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWRkVG9OZXR3b3JrKGRhdGFPYmoubmV3UGVlciwgZGF0YU9iai5uZXdTaXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVtb3ZlIGZyb20gbmV0d29yayc6XG4gICAgICAgICAgdGhpcy5jb250cm9sbGVyLnJlbW92ZUZyb21OZXR3b3JrKGRhdGFPYmoub2xkUGVlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5jb250cm9sbGVyLmhhbmRsZVJlbW90ZU9wZXJhdGlvbihkYXRhT2JqKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJhbmRvbUlkKCk6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IHBvc3NDb25ucyA9IHRoaXMuaW5Db25ucy5maWx0ZXIoY29ubiA9PiB0aGlzLnBlZXIuaWQgIT09IGNvbm4ucGVlcik7XG4gICAgY29uc3QgcmFuZG9tSWR4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9zc0Nvbm5zLmxlbmd0aCk7XG4gICAgaWYgKHBvc3NDb25uc1tyYW5kb21JZHhdKSB7XG4gICAgICByZXR1cm4gcG9zc0Nvbm5zW3JhbmRvbUlkeF0ucGVlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgb25Db25uQ2xvc2UoY29ubmVjdGlvbjogRGF0YUNvbm5lY3Rpb24pIHtcbiAgICBjb25uZWN0aW9uLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlRnJvbUNvbm5lY3Rpb25zKGNvbm5lY3Rpb24ucGVlcik7XG4gICAgICBpZiAoIXRoaXMuaGFzUmVhY2hlZE1heCgpKSB7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5maW5kTmV3VGFyZ2V0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnJvYWRjYXN0O1xuIiwiY2xhc3MgQ2hhciB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBjb3VudGVyLCBzaXRlSWQsIGlkZW50aWZpZXJzKSB7XG4gICAgdGhpcy5wb3NpdGlvbiA9IGlkZW50aWZpZXJzO1xuICAgIHRoaXMuY291bnRlciA9IGNvdW50ZXI7XG4gICAgdGhpcy5zaXRlSWQgPSBzaXRlSWQ7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgY29tcGFyZVRvKG90aGVyQ2hhcikge1xuICAgIGxldCBjb21wO1xuICAgIGxldCBpZDE7XG4gICAgbGV0IGlkMjtcbiAgICBjb25zdCBwb3MxID0gdGhpcy5wb3NpdGlvbjtcbiAgICBjb25zdCBwb3MyID0gb3RoZXJDaGFyLnBvc2l0aW9uO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihwb3MxLmxlbmd0aCwgcG9zMi5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGlkMSA9IHBvczFbaV07XG4gICAgICBpZDIgPSBwb3MyW2ldO1xuICAgICAgY29tcCA9IGlkMS5jb21wYXJlVG8oaWQyKTtcblxuICAgICAgaWYgKGNvbXAgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvczEubGVuZ3RoIDwgcG9zMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKHBvczEubGVuZ3RoID4gcG9zMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcjtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCBQZWVyIGZyb20gJ3BlZXJqcyc7XG5cbmltcG9ydCBDUkRUIGZyb20gJy4vY3JkdCc7XG5pbXBvcnQgQ2hhciBmcm9tICcuL2NoYXInO1xuaW1wb3J0IElkZW50aWZpZXIgZnJvbSAnLi9pZGVudGlmaWVyJztcbmltcG9ydCBWZXJzaW9uVmVjdG9yIGZyb20gJy4vdmVyc2lvblZlY3Rvcic7XG5pbXBvcnQgVmVyc2lvbiwgeyB0eXBlIFZlcnNpb25EYXRhIH0gZnJvbSAnLi92ZXJzaW9uJztcbmltcG9ydCBCcm9hZGNhc3QsIHsgdHlwZSBFZGl0T3BlcmF0aW9uLCB0eXBlIFN5bmNPcGVyYXRpb24gfSBmcm9tICcuL2Jyb2FkY2FzdCc7XG5pbXBvcnQgdHlwZSB7IEFjZVBvc2l0aW9uIH0gZnJvbSAnLi4vYWNlVHlwZXMnO1xuXG5leHBvcnQgdHlwZSBQb3NpdGlvbiA9IHt8XG4gIGxpbmU6IG51bWJlcixcbiAgY2g6IG51bWJlcixcbnx9O1xuXG5leHBvcnQgdHlwZSBDb250cm9sbGVyQWN0aW9uID1cbiAgfCB7fCB0eXBlOiAnUkVNT1ZFX0NVUlNPUicsIHNpdGVJZDogc3RyaW5nIHx9XG4gIHwge3wgdHlwZTogJ0lOU0VSVCcsIHNpdGVJZDogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBzdGFydDogQWNlUG9zaXRpb24sIGVuZDogQWNlUG9zaXRpb24gfH1cbiAgfCB7fCB0eXBlOiAnREVMRVRFJywgc2l0ZUlkOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIHN0YXJ0OiBBY2VQb3NpdGlvbiwgZW5kOiBBY2VQb3NpdGlvbiB8fTtcblxudHlwZSBOZXR3b3JrRW50cnkgPSB7fFxuICBwZWVySWQ6IHN0cmluZyxcbiAgc2l0ZUlkOiBzdHJpbmcsXG58fTtcblxuY2xhc3MgQ29udHJvbGxlciB7XG4gIHNpdGVJZDogc3RyaW5nO1xuICBob3N0OiBzdHJpbmc7XG4gIGJ1ZmZlcjogYW55W107XG4gIG5ldHdvcms6IE5ldHdvcmtFbnRyeVtdO1xuICB1cmxJZDogc3RyaW5nIHwgbnVsbDtcbiAgZGlzcGF0Y2g6IChDb250cm9sbGVyQWN0aW9uKSA9PiB2b2lkO1xuXG4gIGJyb2FkY2FzdDogQnJvYWRjYXN0O1xuICB2ZWN0b3I6IFZlcnNpb25WZWN0b3I7XG4gIGNyZHQ6IENSRFQ7XG5cbiAgY29uc3RydWN0b3Ioc2l0ZUlkOiBzdHJpbmcsIHRhcmdldFBlZXJJZDogc3RyaW5nIHwgbnVsbCwgaG9zdDogc3RyaW5nLCBwZWVyOiBQZWVyKSB7XG4gICAgdGhpcy5zaXRlSWQgPSBzaXRlSWQ7XG4gICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMubmV0d29yayA9IFtdO1xuICAgIHRoaXMudXJsSWQgPSB0YXJnZXRQZWVySWQ7XG5cbiAgICAvLyAkRmxvd0V4cGVjdEVycm9yIC0gcGFzc2luZyBub3QgZnVsbHkgaW5pdGlhbGl6ZWQgb2JqZWN0XG4gICAgdGhpcy5icm9hZGNhc3QgPSBuZXcgQnJvYWRjYXN0KHRoaXMsIHBlZXIsIHRhcmdldFBlZXJJZCk7XG4gICAgdGhpcy52ZWN0b3IgPSBuZXcgVmVyc2lvblZlY3Rvcih0aGlzLnNpdGVJZCk7XG4gICAgdGhpcy5jcmR0ID0gbmV3IENSRFQodGhpcyk7XG4gIH1cblxuICBsb3N0Q29ubmVjdGlvbigpIHtcbiAgICBjb25zb2xlLmxvZygnZGlzY29ubmVjdGVkJyk7XG4gIH1cblxuICBwb3B1bGF0ZUNSRFQoaW5pdGlhbFN0cnVjdDogYW55KSB7XG4gICAgY29uc3Qgc3RydWN0ID0gaW5pdGlhbFN0cnVjdC5tYXAobGluZSA9PlxuICAgICAgbGluZS5tYXAoXG4gICAgICAgIGNoID0+XG4gICAgICAgICAgbmV3IENoYXIoXG4gICAgICAgICAgICBjaC52YWx1ZSxcbiAgICAgICAgICAgIGNoLmNvdW50ZXIsXG4gICAgICAgICAgICBjaC5zaXRlSWQsXG4gICAgICAgICAgICBjaC5wb3NpdGlvbi5tYXAoaWQgPT4gbmV3IElkZW50aWZpZXIoaWQuZGlnaXQsIGlkLnNpdGVJZCkpLFxuICAgICAgICAgICksXG4gICAgICApLFxuICAgICk7XG5cbiAgICB0aGlzLmNyZHQuc3RydWN0ID0gc3RydWN0O1xuICB9XG5cbiAgcG9wdWxhdGVWZXJzaW9uVmVjdG9yKGluaXRpYWxWZXJzaW9uczogVmVyc2lvbltdKSB7XG4gICAgY29uc3QgdmVyc2lvbnMgPSBpbml0aWFsVmVyc2lvbnMubWFwKHZlciA9PiB7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gbmV3IFZlcnNpb24odmVyLnNpdGVJZCk7XG4gICAgICB2ZXJzaW9uLmNvdW50ZXIgPSB2ZXIuY291bnRlcjtcbiAgICAgIHZlci5leGNlcHRpb25zLmZvckVhY2goZXggPT4gdmVyc2lvbi5leGNlcHRpb25zLnB1c2goZXgpKTtcbiAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIH0pO1xuXG4gICAgdmVyc2lvbnMuZm9yRWFjaCh2ZXJzaW9uID0+IHRoaXMudmVjdG9yLnZlcnNpb25zLnB1c2godmVyc2lvbikpO1xuICB9XG5cbiAgYWRkVG9OZXR3b3JrKHBlZXJJZDogc3RyaW5nLCBzaXRlSWQ6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5uZXR3b3JrLmZpbmQob2JqID0+IG9iai5zaXRlSWQgPT09IHNpdGVJZCkpIHtcbiAgICAgIHRoaXMubmV0d29yay5wdXNoKHsgcGVlcklkLCBzaXRlSWQgfSk7XG4gICAgICB0aGlzLmJyb2FkY2FzdC5hZGRUb05ldHdvcmsocGVlcklkLCBzaXRlSWQpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUZyb21OZXR3b3JrKHBlZXJJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgcGVlck9iaiA9IHRoaXMubmV0d29yay5maW5kKG9iaiA9PiBvYmoucGVlcklkID09PSBwZWVySWQpO1xuICAgIGNvbnN0IGlkeCA9IHRoaXMubmV0d29yay5pbmRleE9mKHBlZXJPYmopO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgY29uc3QgW3sgc2l0ZUlkIH1dID0gdGhpcy5uZXR3b3JrLnNwbGljZShpZHgsIDEpO1xuICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdSRU1PVkVfQ1VSU09SJywgc2l0ZUlkIH0pO1xuICAgICAgdGhpcy5icm9hZGNhc3QucmVtb3ZlRnJvbU5ldHdvcmsocGVlcklkKTtcbiAgICB9XG4gIH1cblxuICBmaW5kTmV3VGFyZ2V0KCkge1xuICAgIGNvbnN0IGNvbm5lY3RlZCA9IHRoaXMuYnJvYWRjYXN0Lm91dENvbm5zLm1hcChjb25uID0+IGNvbm4ucGVlcik7XG4gICAgY29uc3QgdW5jb25uZWN0ZWQgPSB0aGlzLm5ldHdvcmsuZmlsdGVyKG9iaiA9PiBjb25uZWN0ZWQuaW5kZXhPZihvYmoucGVlcklkKSA9PT0gLTEpO1xuXG4gICAgY29uc3QgcG9zc2libGVUYXJnZXRzID0gdW5jb25uZWN0ZWQuZmlsdGVyKG9iaiA9PiBvYmoucGVlcklkICE9PSB0aGlzLmJyb2FkY2FzdC5wZWVyLmlkKTtcblxuICAgIGlmIChwb3NzaWJsZVRhcmdldHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmFuZG9tSWR4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9zc2libGVUYXJnZXRzLmxlbmd0aCk7XG4gICAgICBjb25zdCBuZXdUYXJnZXQgPSBwb3NzaWJsZVRhcmdldHNbcmFuZG9tSWR4XS5wZWVySWQ7XG4gICAgICB0aGlzLmJyb2FkY2FzdC5yZXF1ZXN0Q29ubmVjdGlvbihuZXdUYXJnZXQsIHRoaXMuYnJvYWRjYXN0LnBlZXIuaWQsIHRoaXMuc2l0ZUlkKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTeW5jKHN5bmNPYmo6IFN5bmNPcGVyYXRpb24pIHtcbiAgICBzeW5jT2JqLm5ldHdvcmsuZm9yRWFjaChvYmogPT4gdGhpcy5hZGRUb05ldHdvcmsob2JqLnBlZXJJZCwgb2JqLnNpdGVJZCkpO1xuXG4gICAgaWYgKHRoaXMuY3JkdC50b3RhbENoYXJzKCkgPT09IDApIHtcbiAgICAgIHRoaXMucG9wdWxhdGVDUkRUKHN5bmNPYmouaW5pdGlhbFN0cnVjdCk7XG4gICAgICB0aGlzLnBvcHVsYXRlVmVyc2lvblZlY3RvcihzeW5jT2JqLmluaXRpYWxWZXJzaW9ucyk7XG4gICAgfVxuXG4gICAgdGhpcy5zeW5jQ29tcGxldGVkKHN5bmNPYmoucGVlcklkKTtcbiAgfVxuXG4gIHN5bmNDb21wbGV0ZWQocGVlcklkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjb21wbGV0ZWRNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogJ3N5bmNDb21wbGV0ZWQnLFxuICAgICAgcGVlcklkOiB0aGlzLmJyb2FkY2FzdC5wZWVyLmlkLFxuICAgIH0pO1xuXG4gICAgbGV0IGV4aXN0aW5nQ29ubmVjdGlvbiA9IHRoaXMuYnJvYWRjYXN0Lm91dENvbm5zLmZpbmQoY29ubiA9PiBjb25uLnBlZXIgPT09IHBlZXJJZCk7XG5cbiAgICBpZiAoZXhpc3RpbmdDb25uZWN0aW9uKSB7XG4gICAgICBleGlzdGluZ0Nvbm5lY3Rpb24uc2VuZChjb21wbGV0ZWRNZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5ld0Nvbm5lY3Rpb246IFBlZXIuRGF0YUNvbm5lY3Rpb24gPSB0aGlzLmJyb2FkY2FzdC5wZWVyLmNvbm5lY3QocGVlcklkKTtcbiAgICAgIHRoaXMuYnJvYWRjYXN0LmFkZFRvT3V0Q29ubnMobmV3Q29ubmVjdGlvbik7XG4gICAgICBuZXdDb25uZWN0aW9uLm9uKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICBuZXdDb25uZWN0aW9uLnNlbmQoY29tcGxldGVkTWVzc2FnZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVSZW1vdGVPcGVyYXRpb24ob3BlcmF0aW9uOiBFZGl0T3BlcmF0aW9uKSB7XG4gICAgaWYgKHRoaXMudmVjdG9yLmhhc0JlZW5BcHBsaWVkKG9wZXJhdGlvbi52ZXJzaW9uKSkgcmV0dXJuO1xuXG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSAnaW5zZXJ0Jykge1xuICAgICAgdGhpcy5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24pO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKG9wZXJhdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9jZXNzRGVsZXRpb25CdWZmZXIoKTtcbiAgICB0aGlzLmJyb2FkY2FzdC5zZW5kKG9wZXJhdGlvbik7XG4gIH1cblxuICBwcm9jZXNzRGVsZXRpb25CdWZmZXIoKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBkZWxldGVPcGVyYXRpb247XG5cbiAgICB3aGlsZSAoaSA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgZGVsZXRlT3BlcmF0aW9uID0gdGhpcy5idWZmZXJbaV07XG5cbiAgICAgIGlmICh0aGlzLmhhc0luc2VydGlvbkJlZW5BcHBsaWVkKGRlbGV0ZU9wZXJhdGlvbikpIHtcbiAgICAgICAgdGhpcy5hcHBseU9wZXJhdGlvbihkZWxldGVPcGVyYXRpb24pO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zcGxpY2UoaSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFzSW5zZXJ0aW9uQmVlbkFwcGxpZWQob3BlcmF0aW9uOiBFZGl0T3BlcmF0aW9uKSB7XG4gICAgY29uc3QgY2hhclZlcnNpb24gPSB7IHNpdGVJZDogb3BlcmF0aW9uLmNoYXIuc2l0ZUlkLCBjb3VudGVyOiBvcGVyYXRpb24uY2hhci5jb3VudGVyIH07XG4gICAgcmV0dXJuIHRoaXMudmVjdG9yLmhhc0JlZW5BcHBsaWVkKGNoYXJWZXJzaW9uKTtcbiAgfVxuXG4gIGFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbjogRWRpdE9wZXJhdGlvbikge1xuICAgIGNvbnN0IHsgY2hhciB9ID0gb3BlcmF0aW9uO1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gY2hhci5wb3NpdGlvbi5tYXAocG9zID0+IG5ldyBJZGVudGlmaWVyKHBvcy5kaWdpdCwgcG9zLnNpdGVJZCkpO1xuICAgIGNvbnN0IG5ld0NoYXIgPSBuZXcgQ2hhcihjaGFyLnZhbHVlLCBjaGFyLmNvdW50ZXIsIGNoYXIuc2l0ZUlkLCBpZGVudGlmaWVycyk7XG5cbiAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdpbnNlcnQnKSB7XG4gICAgICB0aGlzLmNyZHQuaGFuZGxlUmVtb3RlSW5zZXJ0KG5ld0NoYXIpO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICB0aGlzLmNyZHQuaGFuZGxlUmVtb3RlRGVsZXRlKG5ld0NoYXIsIG9wZXJhdGlvbi52ZXJzaW9uLnNpdGVJZCk7XG4gICAgfVxuXG4gICAgdGhpcy52ZWN0b3IudXBkYXRlKG9wZXJhdGlvbi52ZXJzaW9uKTtcbiAgfVxuXG4gIGxvY2FsRGVsZXRlKHN0YXJ0UG9zOiBQb3NpdGlvbiwgZW5kUG9zOiBQb3NpdGlvbikge1xuICAgIHRoaXMuY3JkdC5oYW5kbGVMb2NhbERlbGV0ZShzdGFydFBvcywgZW5kUG9zKTtcbiAgfVxuXG4gIGxvY2FsSW5zZXJ0KGxpbmVzOiBzdHJpbmdbXSwgc3RhcnRQb3M6IFBvc2l0aW9uKSB7XG4gICAgZm9yIChjb25zdCBbaSwgbGluZV0gb2YgbGluZXMuZW50cmllcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoYXIgb2YgbGluZSkge1xuICAgICAgICB0aGlzLmNyZHQuaGFuZGxlTG9jYWxJbnNlcnQoY2hhciwgc3RhcnRQb3MpO1xuICAgICAgICBzdGFydFBvcy5jaCArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKGkgIT09IGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gYWZ0ZXIgZWFjaCBsaW5lLCBpbnNlcnQgYSBuZXdsaW5lXG4gICAgICAgIHRoaXMuY3JkdC5oYW5kbGVMb2NhbEluc2VydCgnXFxuJywgc3RhcnRQb3MpO1xuICAgICAgfVxuICAgICAgc3RhcnRQb3MubGluZSArPSAxO1xuICAgICAgc3RhcnRQb3MuY2ggPSAwO1xuICAgIH1cbiAgfVxuXG4gIGJyb2FkY2FzdEluc2VydGlvbihjaGFyOiBDaGFyKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgdHlwZTogJ2luc2VydCcsXG4gICAgICBjaGFyLFxuICAgICAgdmVyc2lvbjogdGhpcy52ZWN0b3IuZ2V0TG9jYWxWZXJzaW9uKCksXG4gICAgfTtcblxuICAgIHRoaXMuYnJvYWRjYXN0LnNlbmQob3BlcmF0aW9uKTtcbiAgfVxuXG4gIGJyb2FkY2FzdERlbGV0aW9uKGNoYXI6IENoYXIsIHZlcnNpb246IFZlcnNpb25EYXRhKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgdHlwZTogJ2RlbGV0ZScsXG4gICAgICBjaGFyLFxuICAgICAgdmVyc2lvbixcbiAgICB9O1xuXG4gICAgdGhpcy5icm9hZGNhc3Quc2VuZChvcGVyYXRpb24pO1xuICB9XG5cbiAgaW5zZXJ0SW50b0VkaXRvcih2YWx1ZTogc3RyaW5nLCBwb3M6IFBvc2l0aW9uLCBzaXRlSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IHN0YXJ0ID0geyByb3c6IHBvcy5saW5lLCBjb2x1bW46IHBvcy5jaCB9O1xuICAgIGNvbnN0IGVuZCA9IHsgcm93OiBwb3MubGluZSwgY29sdW1uOiBwb3MuY2ggfTtcblxuICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnSU5TRVJUJywgc2l0ZUlkLCB2YWx1ZSwgc3RhcnQsIGVuZCB9KTtcbiAgfVxuXG4gIGRlbGV0ZUZyb21FZGl0b3IodmFsdWU6IHN0cmluZywgcG9zOiBQb3NpdGlvbiwgc2l0ZUlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBzdGFydCA9IHsgcm93OiBwb3MubGluZSwgY29sdW1uOiBwb3MuY2ggfTtcbiAgICBjb25zdCBlbmQgPVxuICAgICAgdmFsdWUgPT09ICdcXG4nID8geyByb3c6IHBvcy5saW5lICsgMSwgY29sdW1uOiAwIH0gOiB7IHJvdzogcG9zLmxpbmUsIGNvbHVtbjogcG9zLmNoICsgMSB9O1xuXG4gICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdERUxFVEUnLCBzaXRlSWQsIHZhbHVlLCBzdGFydCwgZW5kIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRyb2xsZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5pbXBvcnQgSWRlbnRpZmllciBmcm9tICcuL2lkZW50aWZpZXInO1xuaW1wb3J0IENoYXIgZnJvbSAnLi9jaGFyJztcblxuY2xhc3MgQ1JEVCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRyb2xsZXIsIGJhc2UgPSAzMiwgYm91bmRhcnkgPSAxMCwgc3RyYXRlZ3kgPSAncmFuZG9tJykge1xuICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgdGhpcy52ZWN0b3IgPSBjb250cm9sbGVyLnZlY3RvcjtcbiAgICB0aGlzLnN0cnVjdCA9IFtbXV07XG4gICAgdGhpcy5zaXRlSWQgPSBjb250cm9sbGVyLnNpdGVJZDtcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgdGhpcy5zdHJhdGVneUNhY2hlID0gW107XG4gIH1cblxuICBoYW5kbGVMb2NhbEluc2VydCh2YWx1ZSwgcG9zKSB7XG4gICAgdGhpcy52ZWN0b3IuaW5jcmVtZW50KCk7XG4gICAgY29uc3QgY2hhciA9IHRoaXMuZ2VuZXJhdGVDaGFyKHZhbHVlLCBwb3MpO1xuICAgIHRoaXMuaW5zZXJ0Q2hhcihjaGFyLCBwb3MpO1xuICAgIHRoaXMuY29udHJvbGxlci5icm9hZGNhc3RJbnNlcnRpb24oY2hhcik7XG4gIH1cblxuICBoYW5kbGVSZW1vdGVJbnNlcnQoY2hhcikge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZmluZEluc2VydFBvc2l0aW9uKGNoYXIpO1xuICAgIHRoaXMuaW5zZXJ0Q2hhcihjaGFyLCBwb3MpO1xuICAgIHRoaXMuY29udHJvbGxlci5pbnNlcnRJbnRvRWRpdG9yKGNoYXIudmFsdWUsIHBvcywgY2hhci5zaXRlSWQpO1xuICB9XG5cbiAgaW5zZXJ0Q2hhcihjaGFyLCBwb3MpIHtcbiAgICBpZiAocG9zLmxpbmUgPT09IHRoaXMuc3RydWN0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5zdHJ1Y3QucHVzaChbXSk7XG4gICAgfVxuXG4gICAgLy8gaWYgaW5zZXJ0aW5nIGEgbmV3bGluZSwgc3BsaXQgbGluZSBpbnRvIHR3byBsaW5lc1xuICAgIGlmIChjaGFyLnZhbHVlID09PSAnXFxuJykge1xuICAgICAgY29uc3QgbGluZUFmdGVyID0gdGhpcy5zdHJ1Y3RbcG9zLmxpbmVdLnNwbGljZShwb3MuY2gpO1xuXG4gICAgICBpZiAobGluZUFmdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0cnVjdFtwb3MubGluZV0uc3BsaWNlKHBvcy5jaCwgMCwgY2hhcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsaW5lQmVmb3JlID0gdGhpcy5zdHJ1Y3RbcG9zLmxpbmVdLmNvbmNhdChjaGFyKTtcbiAgICAgICAgdGhpcy5zdHJ1Y3Quc3BsaWNlKHBvcy5saW5lLCAxLCBsaW5lQmVmb3JlLCBsaW5lQWZ0ZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0cnVjdFtwb3MubGluZV0uc3BsaWNlKHBvcy5jaCwgMCwgY2hhcik7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlTG9jYWxEZWxldGUoc3RhcnRQb3MsIGVuZFBvcykge1xuICAgIGxldCBjaGFycztcbiAgICBsZXQgbmV3bGluZVJlbW92ZWQgPSBmYWxzZTtcblxuICAgIC8vIGZvciBtdWx0aS1saW5lIGRlbGV0ZXNcbiAgICBpZiAoc3RhcnRQb3MubGluZSAhPT0gZW5kUG9zLmxpbmUpIHtcbiAgICAgIC8vIGRlbGV0ZSBjaGFycyBvbiBmaXJzdCBsaW5lIGZyb20gc3RhcnRQb3MuY2ggdG8gZW5kIG9mIGxpbmVcbiAgICAgIG5ld2xpbmVSZW1vdmVkID0gdHJ1ZTtcbiAgICAgIGNoYXJzID0gdGhpcy5kZWxldGVNdWx0aXBsZUxpbmVzKHN0YXJ0UG9zLCBlbmRQb3MpO1xuXG4gICAgICAvLyBzaW5nbGUtbGluZSBkZWxldGVzXG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYXJzID0gdGhpcy5kZWxldGVTaW5nbGVMaW5lKHN0YXJ0UG9zLCBlbmRQb3MpO1xuXG4gICAgICBpZiAoY2hhcnMuZmluZChjaGFyID0+IGNoYXIudmFsdWUgPT09ICdcXG4nKSkgbmV3bGluZVJlbW92ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuYnJvYWRjYXN0KGNoYXJzKTtcbiAgICB0aGlzLnJlbW92ZUVtcHR5TGluZXMoKTtcblxuICAgIGlmIChuZXdsaW5lUmVtb3ZlZCAmJiB0aGlzLnN0cnVjdFtzdGFydFBvcy5saW5lICsgMV0pIHtcbiAgICAgIHRoaXMubWVyZ2VMaW5lcyhzdGFydFBvcy5saW5lKTtcbiAgICB9XG4gIH1cblxuICBicm9hZGNhc3QoY2hhcnMpIHtcbiAgICBjaGFycy5mb3JFYWNoKGNoYXIgPT4ge1xuICAgICAgdGhpcy52ZWN0b3IuaW5jcmVtZW50KCk7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIuYnJvYWRjYXN0RGVsZXRpb24oY2hhciwgdGhpcy52ZWN0b3IuZ2V0TG9jYWxWZXJzaW9uKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgZGVsZXRlTXVsdGlwbGVMaW5lcyhzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgbGV0IGNoYXJzID0gdGhpcy5zdHJ1Y3Rbc3RhcnRQb3MubGluZV0uc3BsaWNlKHN0YXJ0UG9zLmNoKTtcbiAgICBsZXQgbGluZTtcblxuICAgIGZvciAobGluZSA9IHN0YXJ0UG9zLmxpbmUgKyAxOyBsaW5lIDwgZW5kUG9zLmxpbmU7IGxpbmUrKykge1xuICAgICAgY2hhcnMgPSBjaGFycy5jb25jYXQodGhpcy5zdHJ1Y3RbbGluZV0uc3BsaWNlKDApKTtcbiAgICB9XG5cbiAgICAvLyB0b2RvIGZvciBsb29wIGluc2lkZSBjcmR0XG4gICAgaWYgKHRoaXMuc3RydWN0W2VuZFBvcy5saW5lXSkge1xuICAgICAgY2hhcnMgPSBjaGFycy5jb25jYXQodGhpcy5zdHJ1Y3RbZW5kUG9zLmxpbmVdLnNwbGljZSgwLCBlbmRQb3MuY2gpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnM7XG4gIH1cblxuICBkZWxldGVTaW5nbGVMaW5lKHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICBjb25zdCBjaGFyTnVtID0gZW5kUG9zLmNoIC0gc3RhcnRQb3MuY2g7XG4gICAgY29uc3QgY2hhcnMgPSB0aGlzLnN0cnVjdFtzdGFydFBvcy5saW5lXS5zcGxpY2Uoc3RhcnRQb3MuY2gsIGNoYXJOdW0pO1xuXG4gICAgcmV0dXJuIGNoYXJzO1xuICB9XG5cbiAgLy8gd2hlbiBkZWxldGluZyBuZXdsaW5lLCBjb25jYXQgbGluZSB3aXRoIG5leHQgbGluZVxuICBtZXJnZUxpbmVzKGxpbmUpIHtcbiAgICBjb25zdCBtZXJnZWRMaW5lID0gdGhpcy5zdHJ1Y3RbbGluZV0uY29uY2F0KHRoaXMuc3RydWN0W2xpbmUgKyAxXSk7XG4gICAgdGhpcy5zdHJ1Y3Quc3BsaWNlKGxpbmUsIDIsIG1lcmdlZExpbmUpO1xuICB9XG5cbiAgcmVtb3ZlRW1wdHlMaW5lcygpIHtcbiAgICBmb3IgKGxldCBsaW5lID0gMDsgbGluZSA8IHRoaXMuc3RydWN0Lmxlbmd0aDsgbGluZSsrKSB7XG4gICAgICBpZiAodGhpcy5zdHJ1Y3RbbGluZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RydWN0LnNwbGljZShsaW5lLCAxKTtcbiAgICAgICAgbGluZS0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cnVjdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RydWN0LnB1c2goW10pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVJlbW90ZURlbGV0ZShjaGFyLCBzaXRlSWQpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLmZpbmRQb3NpdGlvbihjaGFyKTtcblxuICAgIGlmICghcG9zKSByZXR1cm47XG5cbiAgICB0aGlzLnN0cnVjdFtwb3MubGluZV0uc3BsaWNlKHBvcy5jaCwgMSk7XG5cbiAgICBpZiAoY2hhci52YWx1ZSA9PT0gJ1xcbicgJiYgdGhpcy5zdHJ1Y3RbcG9zLmxpbmUgKyAxXSkge1xuICAgICAgdGhpcy5tZXJnZUxpbmVzKHBvcy5saW5lKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZUVtcHR5TGluZXMoKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIuZGVsZXRlRnJvbUVkaXRvcihjaGFyLnZhbHVlLCBwb3MsIHNpdGVJZCk7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnN0cnVjdC5sZW5ndGggPT09IDEgJiYgdGhpcy5zdHJ1Y3RbMF0ubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgZmluZFBvc2l0aW9uKGNoYXIpIHtcbiAgICBsZXQgbWluTGluZSA9IDA7XG4gICAgY29uc3QgdG90YWxMaW5lcyA9IHRoaXMuc3RydWN0Lmxlbmd0aDtcbiAgICBsZXQgbWF4TGluZSA9IHRvdGFsTGluZXMgLSAxO1xuICAgIGNvbnN0IGxhc3RMaW5lID0gdGhpcy5zdHJ1Y3RbbWF4TGluZV07XG4gICAgbGV0IGN1cnJlbnRMaW5lO1xuICAgIGxldCBtaWRMaW5lO1xuICAgIGxldCBjaGFySWR4O1xuICAgIGxldCBtaW5DdXJyZW50TGluZTtcbiAgICBsZXQgbGFzdENoYXI7XG4gICAgbGV0IG1heEN1cnJlbnRMaW5lO1xuICAgIGxldCBtaW5MYXN0Q2hhcjtcbiAgICBsZXQgbWF4TGFzdENoYXI7XG5cbiAgICAvLyBjaGVjayBpZiBzdHJ1Y3QgaXMgZW1wdHkgb3IgY2hhciBpcyBsZXNzIHRoYW4gZmlyc3QgY2hhclxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSB8fCBjaGFyLmNvbXBhcmVUbyh0aGlzLnN0cnVjdFswXVswXSkgPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGFzdENoYXIgPSBsYXN0TGluZVtsYXN0TGluZS5sZW5ndGggLSAxXTtcblxuICAgIC8vIGNoYXIgaXMgZ3JlYXRlciB0aGFuIGFsbCBleGlzdGluZyBjaGFycyAoaW5zZXJ0IGF0IGVuZClcbiAgICBpZiAoY2hhci5jb21wYXJlVG8obGFzdENoYXIpID4gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGJpbmFyeSBzZWFyY2hcbiAgICB3aGlsZSAobWluTGluZSArIDEgPCBtYXhMaW5lKSB7XG4gICAgICBtaWRMaW5lID0gTWF0aC5mbG9vcihtaW5MaW5lICsgKG1heExpbmUgLSBtaW5MaW5lKSAvIDIpO1xuICAgICAgY3VycmVudExpbmUgPSB0aGlzLnN0cnVjdFttaWRMaW5lXTtcbiAgICAgIGxhc3RDaGFyID0gY3VycmVudExpbmVbY3VycmVudExpbmUubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChjaGFyLmNvbXBhcmVUbyhsYXN0Q2hhcikgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgbGluZTogbWlkTGluZSwgY2g6IGN1cnJlbnRMaW5lLmxlbmd0aCAtIDEgfTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhci5jb21wYXJlVG8obGFzdENoYXIpIDwgMCkge1xuICAgICAgICBtYXhMaW5lID0gbWlkTGluZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbkxpbmUgPSBtaWRMaW5lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGJldHdlZW4gbWluIGFuZCBtYXggbGluZS5cbiAgICBtaW5DdXJyZW50TGluZSA9IHRoaXMuc3RydWN0W21pbkxpbmVdO1xuICAgIG1pbkxhc3RDaGFyID0gbWluQ3VycmVudExpbmVbbWluQ3VycmVudExpbmUubGVuZ3RoIC0gMV07XG4gICAgbWF4Q3VycmVudExpbmUgPSB0aGlzLnN0cnVjdFttYXhMaW5lXTtcbiAgICBtYXhMYXN0Q2hhciA9IG1heEN1cnJlbnRMaW5lW21heEN1cnJlbnRMaW5lLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGNoYXIuY29tcGFyZVRvKG1pbkxhc3RDaGFyKSA8PSAwKSB7XG4gICAgICBjaGFySWR4ID0gdGhpcy5maW5kSW5kZXhJbkxpbmUoY2hhciwgbWluQ3VycmVudExpbmUpO1xuICAgICAgcmV0dXJuIHsgbGluZTogbWluTGluZSwgY2g6IGNoYXJJZHggfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhcklkeCA9IHRoaXMuZmluZEluZGV4SW5MaW5lKGNoYXIsIG1heEN1cnJlbnRMaW5lKTtcbiAgICAgIHJldHVybiB7IGxpbmU6IG1heExpbmUsIGNoOiBjaGFySWR4IH07XG4gICAgfVxuICB9XG5cbiAgZmluZEluZGV4SW5MaW5lKGNoYXIsIGxpbmUpIHtcbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IHJpZ2h0ID0gbGluZS5sZW5ndGggLSAxO1xuICAgIGxldCBtaWQ7XG4gICAgbGV0IGNvbXBhcmVOdW07XG5cbiAgICBpZiAobGluZS5sZW5ndGggPT09IDAgfHwgY2hhci5jb21wYXJlVG8obGluZVtsZWZ0XSkgPCAwKSB7XG4gICAgICByZXR1cm4gbGVmdDtcbiAgICB9IGVsc2UgaWYgKGNoYXIuY29tcGFyZVRvKGxpbmVbcmlnaHRdKSA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cnVjdC5sZW5ndGg7XG4gICAgfVxuXG4gICAgd2hpbGUgKGxlZnQgKyAxIDwgcmlnaHQpIHtcbiAgICAgIG1pZCA9IE1hdGguZmxvb3IobGVmdCArIChyaWdodCAtIGxlZnQpIC8gMik7XG4gICAgICBjb21wYXJlTnVtID0gY2hhci5jb21wYXJlVG8obGluZVttaWRdKTtcblxuICAgICAgaWYgKGNvbXBhcmVOdW0gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH0gZWxzZSBpZiAoY29tcGFyZU51bSA+IDApIHtcbiAgICAgICAgbGVmdCA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGFyLmNvbXBhcmVUbyhsaW5lW2xlZnRdKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfSBlbHNlIGlmIChjaGFyLmNvbXBhcmVUbyhsaW5lW3JpZ2h0XSkgPT09IDApIHtcbiAgICAgIHJldHVybiByaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvdWxkIGJlIHJlZmFjdG9yZWQgdG8gbG9vayBwcmV0dGllclxuICBmaW5kSW5zZXJ0UG9zaXRpb24oY2hhcikge1xuICAgIGxldCBtaW5MaW5lID0gMDtcbiAgICBjb25zdCB0b3RhbExpbmVzID0gdGhpcy5zdHJ1Y3QubGVuZ3RoO1xuICAgIGxldCBtYXhMaW5lID0gdG90YWxMaW5lcyAtIDE7XG4gICAgY29uc3QgbGFzdExpbmUgPSB0aGlzLnN0cnVjdFttYXhMaW5lXTtcbiAgICBsZXQgY3VycmVudExpbmU7XG4gICAgbGV0IG1pZExpbmU7XG4gICAgbGV0IGNoYXJJZHg7XG4gICAgbGV0IG1pbkN1cnJlbnRMaW5lO1xuICAgIGxldCBsYXN0Q2hhcjtcbiAgICBsZXQgbWF4Q3VycmVudExpbmU7XG4gICAgbGV0IG1pbkxhc3RDaGFyO1xuICAgIGxldCBtYXhMYXN0Q2hhcjtcblxuICAgIC8vIGNoZWNrIGlmIHN0cnVjdCBpcyBlbXB0eSBvciBjaGFyIGlzIGxlc3MgdGhhbiBmaXJzdCBjaGFyXG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpIHx8IGNoYXIuY29tcGFyZVRvKHRoaXMuc3RydWN0WzBdWzBdKSA8PSAwKSB7XG4gICAgICByZXR1cm4geyBsaW5lOiAwLCBjaDogMCB9O1xuICAgIH1cblxuICAgIGxhc3RDaGFyID0gbGFzdExpbmVbbGFzdExpbmUubGVuZ3RoIC0gMV07XG5cbiAgICAvLyBjaGFyIGlzIGdyZWF0ZXIgdGhhbiBhbGwgZXhpc3RpbmcgY2hhcnMgKGluc2VydCBhdCBlbmQpXG4gICAgaWYgKGNoYXIuY29tcGFyZVRvKGxhc3RDaGFyKSA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRFbmRQb3NpdGlvbihsYXN0Q2hhciwgbGFzdExpbmUsIHRvdGFsTGluZXMpO1xuICAgIH1cblxuICAgIC8vIGJpbmFyeSBzZWFyY2hcbiAgICB3aGlsZSAobWluTGluZSArIDEgPCBtYXhMaW5lKSB7XG4gICAgICBtaWRMaW5lID0gTWF0aC5mbG9vcihtaW5MaW5lICsgKG1heExpbmUgLSBtaW5MaW5lKSAvIDIpO1xuICAgICAgY3VycmVudExpbmUgPSB0aGlzLnN0cnVjdFttaWRMaW5lXTtcbiAgICAgIGxhc3RDaGFyID0gY3VycmVudExpbmVbY3VycmVudExpbmUubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChjaGFyLmNvbXBhcmVUbyhsYXN0Q2hhcikgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgbGluZTogbWlkTGluZSwgY2g6IGN1cnJlbnRMaW5lLmxlbmd0aCAtIDEgfTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhci5jb21wYXJlVG8obGFzdENoYXIpIDwgMCkge1xuICAgICAgICBtYXhMaW5lID0gbWlkTGluZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbkxpbmUgPSBtaWRMaW5lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGJldHdlZW4gbWluIGFuZCBtYXggbGluZS5cbiAgICBtaW5DdXJyZW50TGluZSA9IHRoaXMuc3RydWN0W21pbkxpbmVdO1xuICAgIG1pbkxhc3RDaGFyID0gbWluQ3VycmVudExpbmVbbWluQ3VycmVudExpbmUubGVuZ3RoIC0gMV07XG4gICAgbWF4Q3VycmVudExpbmUgPSB0aGlzLnN0cnVjdFttYXhMaW5lXTtcbiAgICBtYXhMYXN0Q2hhciA9IG1heEN1cnJlbnRMaW5lW21heEN1cnJlbnRMaW5lLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGNoYXIuY29tcGFyZVRvKG1pbkxhc3RDaGFyKSA8PSAwKSB7XG4gICAgICBjaGFySWR4ID0gdGhpcy5maW5kSW5zZXJ0SW5kZXhJbkxpbmUoY2hhciwgbWluQ3VycmVudExpbmUpO1xuICAgICAgcmV0dXJuIHsgbGluZTogbWluTGluZSwgY2g6IGNoYXJJZHggfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhcklkeCA9IHRoaXMuZmluZEluc2VydEluZGV4SW5MaW5lKGNoYXIsIG1heEN1cnJlbnRMaW5lKTtcbiAgICAgIHJldHVybiB7IGxpbmU6IG1heExpbmUsIGNoOiBjaGFySWR4IH07XG4gICAgfVxuICB9XG5cbiAgZmluZEVuZFBvc2l0aW9uKGxhc3RDaGFyLCBsYXN0TGluZSwgdG90YWxMaW5lcykge1xuICAgIGlmIChsYXN0Q2hhci52YWx1ZSA9PT0gJ1xcbicpIHtcbiAgICAgIHJldHVybiB7IGxpbmU6IHRvdGFsTGluZXMsIGNoOiAwIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IGxpbmU6IHRvdGFsTGluZXMgLSAxLCBjaDogbGFzdExpbmUubGVuZ3RoIH07XG4gICAgfVxuICB9XG5cbiAgLy8gYmluYXJ5IHNlYXJjaCB0byBmaW5kIGNoYXIgaW4gYSBsaW5lXG4gIGZpbmRJbnNlcnRJbmRleEluTGluZShjaGFyLCBsaW5lKSB7XG4gICAgbGV0IGxlZnQgPSAwO1xuICAgIGxldCByaWdodCA9IGxpbmUubGVuZ3RoIC0gMTtcbiAgICBsZXQgbWlkO1xuICAgIGxldCBjb21wYXJlTnVtO1xuXG4gICAgaWYgKGxpbmUubGVuZ3RoID09PSAwIHx8IGNoYXIuY29tcGFyZVRvKGxpbmVbbGVmdF0pIDwgMCkge1xuICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfSBlbHNlIGlmIChjaGFyLmNvbXBhcmVUbyhsaW5lW3JpZ2h0XSkgPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJ1Y3QubGVuZ3RoO1xuICAgIH1cblxuICAgIHdoaWxlIChsZWZ0ICsgMSA8IHJpZ2h0KSB7XG4gICAgICBtaWQgPSBNYXRoLmZsb29yKGxlZnQgKyAocmlnaHQgLSBsZWZ0KSAvIDIpO1xuICAgICAgY29tcGFyZU51bSA9IGNoYXIuY29tcGFyZVRvKGxpbmVbbWlkXSk7XG5cbiAgICAgIGlmIChjb21wYXJlTnVtID09PSAwKSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmVOdW0gPiAwKSB7XG4gICAgICAgIGxlZnQgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByaWdodCA9IG1pZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hhci5jb21wYXJlVG8obGluZVtsZWZ0XSkgPT09IDApIHtcbiAgICAgIHJldHVybiBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmlnaHQ7XG4gICAgfVxuICB9XG5cbiAgZmluZFBvc0JlZm9yZShwb3MpIHtcbiAgICBsZXQgeyBjaCB9ID0gcG9zO1xuICAgIGxldCB7IGxpbmUgfSA9IHBvcztcblxuICAgIGlmIChjaCA9PT0gMCAmJiBsaW5lID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMCAmJiBsaW5lICE9PSAwKSB7XG4gICAgICBsaW5lIC09IDE7XG4gICAgICBjaCA9IHRoaXMuc3RydWN0W2xpbmVdLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJ1Y3RbbGluZV1bY2ggLSAxXS5wb3NpdGlvbjtcbiAgfVxuXG4gIGZpbmRQb3NBZnRlcihwb3MpIHtcbiAgICBsZXQgeyBjaCB9ID0gcG9zO1xuICAgIGxldCB7IGxpbmUgfSA9IHBvcztcblxuICAgIGNvbnN0IG51bUxpbmVzID0gdGhpcy5zdHJ1Y3QubGVuZ3RoO1xuICAgIGNvbnN0IG51bUNoYXJzID0gKHRoaXMuc3RydWN0W2xpbmVdICYmIHRoaXMuc3RydWN0W2xpbmVdLmxlbmd0aCkgfHwgMDtcblxuICAgIGlmIChsaW5lID09PSBudW1MaW5lcyAtIDEgJiYgY2ggPT09IG51bUNoYXJzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChsaW5lIDwgbnVtTGluZXMgLSAxICYmIGNoID09PSBudW1DaGFycykge1xuICAgICAgbGluZSArPSAxO1xuICAgICAgY2ggPSAwO1xuICAgIH0gZWxzZSBpZiAobGluZSA+IG51bUxpbmVzIC0gMSAmJiBjaCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cnVjdFtsaW5lXVtjaF0ucG9zaXRpb247XG4gIH1cblxuICBnZW5lcmF0ZUNoYXIodmFsLCBwb3MpIHtcbiAgICBjb25zdCBwb3NCZWZvcmUgPSB0aGlzLmZpbmRQb3NCZWZvcmUocG9zKTtcbiAgICBjb25zdCBwb3NBZnRlciA9IHRoaXMuZmluZFBvc0FmdGVyKHBvcyk7XG4gICAgY29uc3QgbmV3UG9zID0gdGhpcy5nZW5lcmF0ZVBvc0JldHdlZW4ocG9zQmVmb3JlLCBwb3NBZnRlcik7XG5cbiAgICByZXR1cm4gbmV3IENoYXIodmFsLCB0aGlzLnZlY3Rvci5sb2NhbFZlcnNpb24uY291bnRlciwgdGhpcy5zaXRlSWQsIG5ld1Bvcyk7XG4gIH1cblxuICByZXRyaWV2ZVN0cmF0ZWd5KGxldmVsKSB7XG4gICAgaWYgKHRoaXMuc3RyYXRlZ3lDYWNoZVtsZXZlbF0pIHJldHVybiB0aGlzLnN0cmF0ZWd5Q2FjaGVbbGV2ZWxdO1xuICAgIGxldCBzdHJhdGVneTtcblxuICAgIHN3aXRjaCAodGhpcy5zdHJhdGVneSkge1xuICAgICAgY2FzZSAncGx1cyc6XG4gICAgICAgIHN0cmF0ZWd5ID0gJysnO1xuICAgICAgY2FzZSAnbWludXMnOlxuICAgICAgICBzdHJhdGVneSA9ICctJztcbiAgICAgIGNhc2UgJ3JhbmRvbSc6XG4gICAgICAgIHN0cmF0ZWd5ID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpKSA9PT0gMCA/ICcrJyA6ICctJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN0cmF0ZWd5ID0gbGV2ZWwgJSAyID09PSAwID8gJysnIDogJy0nO1xuICAgIH1cblxuICAgIHRoaXMuc3RyYXRlZ3lDYWNoZVtsZXZlbF0gPSBzdHJhdGVneTtcbiAgICByZXR1cm4gc3RyYXRlZ3k7XG4gIH1cblxuICBnZW5lcmF0ZVBvc0JldHdlZW4ocG9zMSwgcG9zMiwgbmV3UG9zID0gW10sIGxldmVsID0gMCkge1xuICAgIC8vIGNoYW5nZSAyIHRvIGFueSBvdGhlciBudW1iZXIgdG8gY2hhbmdlIGJhc2UgbXVsdGlwbGljYXRpb25cbiAgICBjb25zdCBiYXNlID0gTWF0aC5wb3coMiwgbGV2ZWwpICogdGhpcy5iYXNlO1xuICAgIGNvbnN0IGJvdW5kYXJ5U3RyYXRlZ3kgPSB0aGlzLnJldHJpZXZlU3RyYXRlZ3kobGV2ZWwpO1xuXG4gICAgY29uc3QgaWQxID0gcG9zMVswXSB8fCBuZXcgSWRlbnRpZmllcigwLCB0aGlzLnNpdGVJZCk7XG4gICAgY29uc3QgaWQyID0gcG9zMlswXSB8fCBuZXcgSWRlbnRpZmllcihiYXNlLCB0aGlzLnNpdGVJZCk7XG5cbiAgICBpZiAoaWQyLmRpZ2l0IC0gaWQxLmRpZ2l0ID4gMSkge1xuICAgICAgY29uc3QgbmV3RGlnaXQgPSB0aGlzLmdlbmVyYXRlSWRCZXR3ZWVuKGlkMS5kaWdpdCwgaWQyLmRpZ2l0LCBib3VuZGFyeVN0cmF0ZWd5KTtcbiAgICAgIG5ld1Bvcy5wdXNoKG5ldyBJZGVudGlmaWVyKG5ld0RpZ2l0LCB0aGlzLnNpdGVJZCkpO1xuICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICB9IGVsc2UgaWYgKGlkMi5kaWdpdCAtIGlkMS5kaWdpdCA9PT0gMSkge1xuICAgICAgbmV3UG9zLnB1c2goaWQxKTtcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUG9zQmV0d2Vlbihwb3MxLnNsaWNlKDEpLCBbXSwgbmV3UG9zLCBsZXZlbCArIDEpO1xuICAgIH0gZWxzZSBpZiAoaWQxLmRpZ2l0ID09PSBpZDIuZGlnaXQpIHtcbiAgICAgIGlmIChpZDEuc2l0ZUlkIDwgaWQyLnNpdGVJZCkge1xuICAgICAgICBuZXdQb3MucHVzaChpZDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVBvc0JldHdlZW4ocG9zMS5zbGljZSgxKSwgW10sIG5ld1BvcywgbGV2ZWwgKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaWQxLnNpdGVJZCA9PT0gaWQyLnNpdGVJZCkge1xuICAgICAgICBuZXdQb3MucHVzaChpZDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVBvc0JldHdlZW4ocG9zMS5zbGljZSgxKSwgcG9zMi5zbGljZSgxKSwgbmV3UG9zLCBsZXZlbCArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXggUG9zaXRpb24gU29ydGluZycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKlxuTWF0aC5yYW5kb20gZ2l2ZXMgeW91IGEgcmFuZ2UgdGhhdCBpcyBpbmNsdXNpdmUgb2YgdGhlIG1pbiBhbmQgZXhjbHVzaXZlIG9mIHRoZSBtYXhcbnNvIGhhdmUgdG8gYWRkIGFuZCBzdWJ0cmFjdCBvbmVzIHRvIGdldCB0aGVtIGFsbCBpbnRvIHRoYXQgZm9ybWF0XG5cbmlmIG1heCAtIG1pbiA8PSBib3VuZGFyeSwgdGhlIGJvdW5kYXJ5IGRvZXNuJ3QgbWF0dGVyXG4gICAgbmV3RGlnaXQgPiBtaW4sIG5ld0RpZ2l0IDwgbWF4XG4gICAgaWUgKG1pbisxLi4ubWF4KVxuICAgIHNvLCBtaW4gPSBtaW4gKyAxXG5pZiBtYXggLSBtaW4gPiBib3VuZGFyeSBhbmQgdGhlIGJvdW5kYXJ5IGlzIG5lZ2F0aXZlXG4gICAgbWluID0gbWF4IC0gYm91bmRhcnlcbiAgICBuZXdEaWdpdCA+PSBtaW4sIG5ld0RpZ2l0IDwgbWF4XG4gICAgaWUgKG1pbi4uLm1heClcbmlmIG1heCAtIG1pbiA+IGJvdW5kYXJ5IGFuZCB0aGUgYm91bmRhcnkgaXMgcG9zaXRpdmVcbiAgICBtYXggPSBtaW4gKyBib3VuZGFyeVxuICAgIG5ld0RpZ2l0ID4gbWluLCBuZXdEaWdpdCA8PSBtYXhcbiAgICBpZSAobWluKzEuLi5tYXgrMSlcbiAgICBzbywgbWluID0gbWluICsgMSBhbmQgbWF4ID0gbWF4ICsgMVxuXG5ub3cgYWxsIGFyZSAobWluLi4ubWF4KVxuKi9cbiAgZ2VuZXJhdGVJZEJldHdlZW4obWluLCBtYXgsIGJvdW5kYXJ5U3RyYXRlZ3kpIHtcbiAgICBpZiAobWF4IC0gbWluIDwgdGhpcy5ib3VuZGFyeSkge1xuICAgICAgbWluICs9IDE7XG4gICAgfSBlbHNlIGlmIChib3VuZGFyeVN0cmF0ZWd5ID09PSAnLScpIHtcbiAgICAgIG1pbiA9IG1heCAtIHRoaXMuYm91bmRhcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbiArPSAxO1xuICAgICAgbWF4ID0gbWluICsgdGhpcy5ib3VuZGFyeTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pbjtcbiAgfVxuXG4gIHRvdGFsQ2hhcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RydWN0Lm1hcChsaW5lID0+IGxpbmUubGVuZ3RoKS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpO1xuICB9XG5cbiAgdG9UZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnN0cnVjdC5tYXAobGluZSA9PiBsaW5lLm1hcChjaGFyID0+IGNoYXIudmFsdWUpLmpvaW4oJycpKS5qb2luKCcnKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDUkRUO1xuIiwiY2xhc3MgSWRlbnRpZmllciB7XG4gIGNvbnN0cnVjdG9yKGRpZ2l0LCBzaXRlSWQpIHtcbiAgICB0aGlzLmRpZ2l0ID0gZGlnaXQ7XG4gICAgdGhpcy5zaXRlSWQgPSBzaXRlSWQ7XG4gIH1cblxuICAvLyBDb21wYXJlIGlkZW50aWZpZXJzIHVzaW5nIHRoZWlyIGRpZ2l0IHZhbHVlIHdpdGggc2l0ZUlEIGFzIHRoZSB0aWVicmVha2VyXG4gIC8vIElmIGlkZW50aWZlcnMgYXJlIGVxdWFsLCByZXR1cm4gMFxuICBjb21wYXJlVG8ob3RoZXJJZCkge1xuICAgIGlmICh0aGlzLmRpZ2l0IDwgb3RoZXJJZC5kaWdpdCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kaWdpdCA+IG90aGVySWQuZGlnaXQpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zaXRlSWQgPCBvdGhlcklkLnNpdGVJZCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zaXRlSWQgPiBvdGhlcklkLnNpdGVJZCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJZGVudGlmaWVyO1xuIiwiLy8gQGZsb3dcblxuZXhwb3J0IHR5cGUgVmVyc2lvbkRhdGEgPSB7fFxuICBzaXRlSWQ6IHN0cmluZyxcbiAgY291bnRlcjogbnVtYmVyLFxufH07XG5cbi8vIENsYXNzIHRoYXQgd3JhcHMgdGhlIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggdmVyc2lvbi5cbi8vIGV4Y2VwdGlvbnMgYXJlIGEgc2V0IG9mIGNvdW50ZXJzIGZvciBvcGVyYXRpb25zIHRoYXQgb3VyIGxvY2FsIENSRFQgaGFzIG5vdFxuLy8gc2VlbiBvciBpbnRlZ3JhdGVkIHlldC4gV2FpdGluZyBmb3IgdGhlc2Ugb3BlcmF0aW9ucy5cbmNsYXNzIFZlcnNpb24ge1xuICBzaXRlSWQ6IHN0cmluZztcbiAgY291bnRlcjogbnVtYmVyO1xuICBleGNlcHRpb25zOiBudW1iZXJbXTtcblxuICBjb25zdHJ1Y3RvcihzaXRlSWQ6IHN0cmluZykge1xuICAgIHRoaXMuc2l0ZUlkID0gc2l0ZUlkO1xuICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgdGhpcy5leGNlcHRpb25zID0gW107XG4gIH1cblxuICAvLyBVcGRhdGUgYSBzaXRlJ3MgdmVyc2lvbiBiYXNlZCBvbiB0aGUgaW5jb21pbmcgb3BlcmF0aW9uIHRoYXQgd2FzIHByb2Nlc3NlZFxuICAvLyBJZiB0aGUgaW5jb21pbmdDb3VudGVyIGlzIGxlc3MgdGhhbiB3ZSBoYWQgcHJldmlvdXNseSBwcm9jZXNzZWQsIHdlIGNhbiByZW1vdmUgaXQgZnJvbSB0aGUgZXhjZXB0aW9uc1xuICAvLyBFbHNlIGlmIHRoZSBpbmNvbWluZ0NvdW50ZXIgaXMgdGhlIG9wZXJhdGlvbiBpbW1lZGlhdGVseSBhZnRlciB0aGUgbGFzdCBvbmUgd2UgcHJvY2VzZWQsIHdlIGp1c3QgaW5jcmVtZW50IG91ciBjb3VudGVyIHRvIHJlZmxlY3QgdGhhdFxuICAvLyBFbHNlLCBhZGQgYW4gZXhjZXB0aW9uIGZvciBlYWNoIGNvdW50ZXIgdmFsdWUgdGhhdCB3ZSBoYXZlbid0IHNlZW4geWV0LCBhbmQgdXBkYXRlIG91ciBjb3VudGVyIHRvIG1hdGNoXG4gIHVwZGF0ZSh2ZXJzaW9uOiBWZXJzaW9uRGF0YSkge1xuICAgIGNvbnN0IGluY29taW5nQ291bnRlciA9IHZlcnNpb24uY291bnRlcjtcblxuICAgIGlmIChpbmNvbWluZ0NvdW50ZXIgPD0gdGhpcy5jb3VudGVyKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZXhjZXB0aW9ucy5pbmRleE9mKGluY29taW5nQ291bnRlcik7XG4gICAgICB0aGlzLmV4Y2VwdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9IGVsc2UgaWYgKGluY29taW5nQ291bnRlciA9PT0gdGhpcy5jb3VudGVyICsgMSkge1xuICAgICAgdGhpcy5jb3VudGVyICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNvdW50ZXIgKyAxOyBpIDwgaW5jb21pbmdDb3VudGVyOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5leGNlcHRpb25zLnB1c2goaSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvdW50ZXIgPSBpbmNvbWluZ0NvdW50ZXI7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZlcnNpb247XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgVmVyc2lvbiwgeyB0eXBlIFZlcnNpb25EYXRhIH0gZnJvbSAnLi92ZXJzaW9uJztcblxuLy8gdmVjdG9yL2xpc3Qgb2YgdmVyc2lvbnMgb2Ygc2l0ZXMgaW4gdGhlIGRpc3RyaWJ1dGVkIHN5c3RlbVxuLy8ga2VlcHMgdHJhY2sgb2YgdGhlIGxhdGVzdCBvcGVyYXRpb24gcmVjZWl2ZWQgZnJvbSBlYWNoIHNpdGUgKGkuZS4gdmVyc2lvbilcbi8vIHByZXZlbnRzIGR1cGxpY2F0ZSBvcGVyYXRpb25zIGZyb20gYmVpbmcgYXBwbGllZCB0byBvdXIgQ1JEVFxuY2xhc3MgVmVyc2lvblZlY3RvciB7XG4gIGxvY2FsVmVyc2lvbjogVmVyc2lvbjtcbiAgdmVyc2lvbnM6IFZlcnNpb25bXTtcblxuICAvLyBpbml0aWFsaXplIGVtcHR5IHZlY3RvciB0byBiZSBzb3J0ZWQgYnkgc2l0ZUlkXG4gIC8vIGluaXRpYWxpemUgVmVyc2lvbi9DbG9jayBmb3IgbG9jYWwgc2l0ZSBhbmQgaW5zZXJ0IGludG8gdmVyc2lvbnMgdmVjdG9yIG9iamVjdFxuICBjb25zdHJ1Y3RvcihzaXRlSWQ6IHN0cmluZykge1xuICAgIHRoaXMubG9jYWxWZXJzaW9uID0gbmV3IFZlcnNpb24oc2l0ZUlkKTtcbiAgICB0aGlzLnZlcnNpb25zID0gW3RoaXMubG9jYWxWZXJzaW9uXTtcbiAgfVxuXG4gIGluY3JlbWVudCgpIHtcbiAgICB0aGlzLmxvY2FsVmVyc2lvbi5jb3VudGVyICs9IDE7XG4gIH1cblxuICAvLyB1cGRhdGVzIHZlY3RvciB3aXRoIG5ldyB2ZXJzaW9uIHJlY2VpdmVkIGZyb20gYW5vdGhlciBzaXRlXG4gIC8vIGlmIHZlY3RvciBkb2Vzbid0IGNvbnRhaW4gdmVyc2lvbiwgaXQncyBjcmVhdGVkIGFuZCBhZGRlZCB0byB2ZWN0b3JcbiAgLy8gY3JlYXRlIGV4Y2VwdGlvbnMgaWYgbmVlZCBiZS5cbiAgdXBkYXRlKGluY29taW5nVmVyc2lvbjogVmVyc2lvbkRhdGEpIHtcbiAgICBjb25zdCBleGlzdGluZ1ZlcnNpb24gPSB0aGlzLnZlcnNpb25zLmZpbmQoXG4gICAgICB2ZXJzaW9uID0+IGluY29taW5nVmVyc2lvbi5zaXRlSWQgPT09IHZlcnNpb24uc2l0ZUlkLFxuICAgICk7XG5cbiAgICBpZiAoIWV4aXN0aW5nVmVyc2lvbikge1xuICAgICAgY29uc3QgbmV3VmVyc2lvbiA9IG5ldyBWZXJzaW9uKGluY29taW5nVmVyc2lvbi5zaXRlSWQpO1xuXG4gICAgICBuZXdWZXJzaW9uLnVwZGF0ZShpbmNvbWluZ1ZlcnNpb24pO1xuICAgICAgdGhpcy52ZXJzaW9ucy5wdXNoKG5ld1ZlcnNpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZ1ZlcnNpb24udXBkYXRlKGluY29taW5nVmVyc2lvbik7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgaWYgaW5jb21pbmcgcmVtb3RlIG9wZXJhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gb3VyIGNyZHRcbiAgaGFzQmVlbkFwcGxpZWQoaW5jb21pbmdWZXJzaW9uOiBWZXJzaW9uRGF0YSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGxvY2FsSW5jb21pbmdWZXJzaW9uID0gdGhpcy5nZXRWZXJzaW9uRnJvbVZlY3RvcihpbmNvbWluZ1ZlcnNpb24pO1xuXG4gICAgaWYgKCFsb2NhbEluY29taW5nVmVyc2lvbikgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgaXNJbmNvbWluZ0xvd2VyID0gaW5jb21pbmdWZXJzaW9uLmNvdW50ZXIgPD0gbG9jYWxJbmNvbWluZ1ZlcnNpb24uY291bnRlcjtcbiAgICBjb25zdCBpc0luRXhjZXB0aW9ucyA9IGxvY2FsSW5jb21pbmdWZXJzaW9uLmV4Y2VwdGlvbnMuaW5jbHVkZXMoaW5jb21pbmdWZXJzaW9uLmNvdW50ZXIpO1xuXG4gICAgcmV0dXJuIGlzSW5jb21pbmdMb3dlciAmJiAhaXNJbkV4Y2VwdGlvbnM7XG4gIH1cblxuICBnZXRWZXJzaW9uRnJvbVZlY3RvcihpbmNvbWluZ1ZlcnNpb246IFZlcnNpb25EYXRhKTogVmVyc2lvbiB8IHZvaWQge1xuICAgIHJldHVybiB0aGlzLnZlcnNpb25zLmZpbmQodmVyc2lvbiA9PiB2ZXJzaW9uLnNpdGVJZCA9PT0gaW5jb21pbmdWZXJzaW9uLnNpdGVJZCk7XG4gIH1cblxuICBnZXRMb2NhbFZlcnNpb24oKTogVmVyc2lvbkRhdGEge1xuICAgIGNvbnN0IHsgc2l0ZUlkLCBjb3VudGVyIH0gPSB0aGlzLmxvY2FsVmVyc2lvbjtcbiAgICByZXR1cm4geyBzaXRlSWQsIGNvdW50ZXIgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBWZXJzaW9uVmVjdG9yO1xuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgUGVlciBmcm9tICdwZWVyanMnO1xuXG5pbXBvcnQgKiBhcyBob29rcyBmcm9tICcuLi8uLi9jb21wb25lbnRzL21pc2MvaG9va3MnO1xuaW1wb3J0IHR5cGUgeyBBY2VDb25maWcsIEFjZU1hcmtlciB9IGZyb20gJy4vYWNlVHlwZXMnO1xuXG5pbXBvcnQgdXNlUmVtb3RlQ3Vyc29ycyBmcm9tICcuL3VzZVJlbW90ZUN1cnNvcnMnO1xuaW1wb3J0IHVzZUNvbnRlbnQgZnJvbSAnLi91c2VDb250ZW50JztcbmltcG9ydCBDb250cm9sbGVyLCB7IHR5cGUgQ29udHJvbGxlckFjdGlvbiB9IGZyb20gJy4vY29uY2xhdmUvY29udHJvbGxlcic7XG5cbmV4cG9ydCB0eXBlIENvbm5lY3Rpb25Db25maWcgPSB7fFxuICBzaXRlSWQ6IHN0cmluZyxcbiAgdGFyZ2V0UGVlcklkOiBzdHJpbmcgfCBudWxsLFxuICBwZWVyT3B0aW9ucz86IGFueSxcbiAgb25PcGVuPzogKGlkOiBzdHJpbmcpID0+IHZvaWQsXG58fTtcblxudHlwZSBDb25jbGF2ZUhvb2sgPSB7fFxuICBtb3VudEFjZUVkaXRvcihcbiAgICBwcm9wczogQWNlQ29uZmlnIHwgbnVsbCxcbiAgKToge3xcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIG1hcmtlcnM6IEFjZU1hcmtlcltdLFxuICAgIC4uLkFjZUNvbmZpZyxcbiAgfH0sXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlQ29uY2xhdmUoXG4gIGNvbm5lY3Rpb25Db25maWc6IENvbm5lY3Rpb25Db25maWcsXG4gIGdldE1hcmtlckNsYXNzTmFtZTogKHNpdGVJZDogc3RyaW5nLCB0eXBlOiAnc2VsZWN0aW9uJyB8ICdjdXJzb3InKSA9PiBzdHJpbmcsXG4pOiBDb25jbGF2ZUhvb2sge1xuICBjb25zdCByZW1vdGVDdXJzb3JzID0gdXNlUmVtb3RlQ3Vyc29ycyhnZXRNYXJrZXJDbGFzc05hbWUpO1xuICBjb25zdCByZW1vdGVDdXJzb3JzRGlzcGF0Y2ggPSByZW1vdGVDdXJzb3JzLmRpc3BhdGNoO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBob29rcy51c2VWYWx1ZSgoKSA9PiB7XG4gICAgY29uc3QgeyBwZWVyT3B0aW9ucywgb25PcGVuLCBzaXRlSWQsIHRhcmdldFBlZXJJZCB9ID0gY29ubmVjdGlvbkNvbmZpZztcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoXG4gICAgICBzaXRlSWQsXG4gICAgICB0YXJnZXRQZWVySWQsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICBsb2NhdGlvbi5vcmlnaW4sXG4gICAgICBuZXcgUGVlcih7XG4gICAgICAgIC4uLnBlZXJPcHRpb25zLFxuICAgICAgICBkZWJ1ZzogMSxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBpZiAob25PcGVuKSBjb250cm9sbGVyLmJyb2FkY2FzdC5wZWVyLm9uKCdvcGVuJywgb25PcGVuKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVtb3RlQ3Vyc29ycy5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdTRVQnLFxuICAgICAgICBzaXRlSWQ6ICdmb28nLFxuICAgICAgICByZW1vdGVDdXJzb3I6IHtcbiAgICAgICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7IHJvdzogMSwgY29sdW1uOiAxIH0sXG4gICAgICAgICAgICBlbmQ6IHsgcm93OiAxLCBjb2x1bW46IDMgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1cnNvcjogeyByb3c6IDEsIGNvbHVtbjogMyB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSwgNTAwMCk7XG5cbiAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgfSk7XG5cbiAgY29uc3QgY29udGVudCA9IHVzZUNvbnRlbnQocmVtb3RlQ3Vyc29yc0Rpc3BhdGNoLCBjb250cm9sbGVyKTtcbiAgY29uc3QgY29udGVudFJlZnJlc2ggPSBjb250ZW50LnJlZnJlc2hWYWx1ZTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbjogQ29udHJvbGxlckFjdGlvbikge1xuICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdSRU1PVkVfQ1VSU09SJzoge1xuICAgICAgICAgIGNvbnN0IHsgc2l0ZUlkIH0gPSBhY3Rpb247XG5cbiAgICAgICAgICByZW1vdGVDdXJzb3JzRGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFJywgc2l0ZUlkIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0lOU0VSVCc6IHtcbiAgICAgICAgICBjb250ZW50UmVmcmVzaCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0RFTEVURSc6IHtcbiAgICAgICAgICBjb250ZW50UmVmcmVzaCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRyb2xsZXIuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgfSwgW2NvbnRyb2xsZXIsIHJlbW90ZUN1cnNvcnNEaXNwYXRjaCwgY29udGVudFJlZnJlc2hdKTtcblxuICByZXR1cm4ge1xuICAgIG1vdW50QWNlRWRpdG9yKGNvbmZpZzogQWNlQ29uZmlnIHwgdm9pZCkge1xuICAgICAgY29uc3QgeyBtYXJrZXJzLCAuLi5wcm9wcyB9ID0gY29uZmlnID8/IHt9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgbWFya2VyczogWy4uLihtYXJrZXJzID8/IFtdKSwgLi4ucmVtb3RlQ3Vyc29ycy5nZXRBY2VNYXJrZXJzKCldLFxuICAgICAgICBvbkNoYW5nZTogY29udGVudC5vbkNoYW5nZSxcbiAgICAgICAgdmFsdWU6IGNvbnRlbnQudmFsdWUsXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB0eXBlIHsgQWNlQ2hhbmdlRXZlbnQgfSBmcm9tICcuL2FjZVR5cGVzJztcbmltcG9ydCB7IHR5cGUgUmVtb3RlQ3Vyc29yc0FjdGlvbiB9IGZyb20gJy4vdXNlUmVtb3RlQ3Vyc29ycyc7XG5cbmltcG9ydCBDb250cm9sbGVyIGZyb20gJy4vY29uY2xhdmUvY29udHJvbGxlcic7XG5cbnR5cGUgQ29udGVudEhvb2sgPSB7fFxuICB2YWx1ZTogc3RyaW5nLFxuICByZWZyZXNoVmFsdWUoKTogdm9pZCxcbiAgb25DaGFuZ2UodmFsdWU6IHN0cmluZywgZXZlbnQ6IEFjZUNoYW5nZUV2ZW50KTogdm9pZCxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VDb250ZW50KFxuICByZW1vdGVDdXJzb3JzRGlzcGF0Y2g6IChSZW1vdGVDdXJzb3JzQWN0aW9uKSA9PiB2b2lkLFxuICBjb250cm9sbGVyOiBDb250cm9sbGVyLFxuKTogQ29udGVudEhvb2sge1xuICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlPHN0cmluZz4oJycpO1xuXG4gIGZ1bmN0aW9uIHJlZnJlc2hWYWx1ZSgpIHtcbiAgICBzZXRWYWx1ZShjb250cm9sbGVyLmNyZHQudG9UZXh0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZSxcbiAgICByZWZyZXNoVmFsdWUsXG4gICAgb25DaGFuZ2UoX3ZhbHVlOiBzdHJpbmcsIHsgYWN0aW9uLCBsaW5lcywgc3RhcnQsIGVuZCB9OiBBY2VDaGFuZ2VFdmVudCkge1xuICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgY2FzZSAnaW5zZXJ0Jzoge1xuICAgICAgICAgIHJlbW90ZUN1cnNvcnNEaXNwYXRjaCh7IHR5cGU6ICdJTlNFUlQnLCBzdGFydCwgZW5kIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIubG9jYWxJbnNlcnQobGluZXMsIHsgbGluZTogc3RhcnQucm93LCBjaDogc3RhcnQuY29sdW1uIH0pO1xuICAgICAgICAgIHJlZnJlc2hWYWx1ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3JlbW92ZSc6IHtcbiAgICAgICAgICByZW1vdGVDdXJzb3JzRGlzcGF0Y2goeyB0eXBlOiAnREVMRVRFJywgc3RhcnQsIGVuZCB9KTtcbiAgICAgICAgICBjb250cm9sbGVyLmxvY2FsRGVsZXRlKFxuICAgICAgICAgICAgeyBsaW5lOiBzdGFydC5yb3csIGNoOiBzdGFydC5jb2x1bW4gfSxcbiAgICAgICAgICAgIHsgbGluZTogZW5kLnJvdywgY2g6IGVuZC5jb2x1bW4gfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlZnJlc2hWYWx1ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IG1hcE9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5pbXBvcnQgdHlwZSB7IEFjZU1hcmtlciwgQWNlUG9zaXRpb24gfSBmcm9tICcuL2FjZVR5cGVzJztcblxudHlwZSBSZW1vdGVDdXJzb3IgPSB7fFxuICBzZWxlY3Rpb246IHt8XG4gICAgc3RhcnQ6IEFjZVBvc2l0aW9uLFxuICAgIGVuZDogQWNlUG9zaXRpb24sXG4gIHx9IHwgbnVsbCxcbiAgY3Vyc29yOiBBY2VQb3NpdGlvbiB8IG51bGwsXG58fTtcblxudHlwZSBSZW1vdGVDdXJzb3JzID0ge3xcbiAgW3NpdGVJZDogc3RyaW5nXTogUmVtb3RlQ3Vyc29yLFxufH07XG5cbmV4cG9ydCB0eXBlIFJlbW90ZUN1cnNvcnNBY3Rpb24gPVxuICB8IHt8IHR5cGU6ICdTRVQnLCBzaXRlSWQ6IHN0cmluZywgcmVtb3RlQ3Vyc29yOiBSZW1vdGVDdXJzb3IgfH1cbiAgfCB7fCB0eXBlOiAnUkVNT1ZFJywgc2l0ZUlkOiBzdHJpbmcgfH1cbiAgfCB7fCB0eXBlOiAnSU5TRVJUJywgc3RhcnQ6IEFjZVBvc2l0aW9uLCBlbmQ6IEFjZVBvc2l0aW9uIHx9XG4gIHwge3wgdHlwZTogJ0RFTEVURScsIHN0YXJ0OiBBY2VQb3NpdGlvbiwgZW5kOiBBY2VQb3NpdGlvbiB8fTtcblxuZnVuY3Rpb24gcmVtb3RlQ3Vyc29yc1JlZHVjZXIoc3RhdGU6IFJlbW90ZUN1cnNvcnMsIGFjdGlvbjogUmVtb3RlQ3Vyc29yc0FjdGlvbik6IFJlbW90ZUN1cnNvcnMge1xuICBmdW5jdGlvbiBtYXBSZW1vdGVDdXJzb3IoZm46IChBY2VQb3NpdGlvbikgPT4gQWNlUG9zaXRpb24pOiAoUmVtb3RlQ3Vyc29yKSA9PiBSZW1vdGVDdXJzb3Ige1xuICAgIHJldHVybiAoeyBzZWxlY3Rpb24sIGN1cnNvciB9KSA9PiB7XG4gICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHsgc3RhcnQ6IGZuKHNlbGVjdGlvbi5zdGFydCksIGVuZDogZm4oc2VsZWN0aW9uLmVuZCkgfTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJzb3IgIT09IG51bGwpIHtcbiAgICAgICAgY3Vyc29yID0gZm4oY3Vyc29yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHNlbGVjdGlvbiwgY3Vyc29yIH07XG4gICAgfTtcbiAgfVxuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdTRVQnOiB7XG4gICAgICBjb25zdCB7IHNpdGVJZCwgcmVtb3RlQ3Vyc29yIH0gPSBhY3Rpb247XG5cbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBbc2l0ZUlkXTogcmVtb3RlQ3Vyc29yIH07XG4gICAgfVxuICAgIGNhc2UgJ1JFTU9WRSc6IHtcbiAgICAgIGNvbnN0IHsgc2l0ZUlkIH0gPSBhY3Rpb247XG5cbiAgICAgIGNvbnN0IHsgW3NpdGVJZF06IF8sIC4uLm5ld1N0YXRlIH0gPSBzdGF0ZTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICB9XG4gICAgY2FzZSAnSU5TRVJUJzoge1xuICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBhY3Rpb247XG5cbiAgICAgIGNvbnN0IHJvd0RlbHRhID0gZW5kLnJvdyAtIHN0YXJ0LnJvdztcbiAgICAgIGNvbnN0IGNvbHVtbkRlbHRhID0gcm93RGVsdGEgPT09IDAgPyBlbmQuY29sdW1uIC0gc3RhcnQuY29sdW1uIDogZW5kLmNvbHVtbjtcblxuICAgICAgZnVuY3Rpb24gbWFwUG9zaXRpb24oeyByb3csIGNvbHVtbiB9OiBBY2VQb3NpdGlvbik6IEFjZVBvc2l0aW9uIHtcbiAgICAgICAgaWYgKHJvdyA+IHN0YXJ0LnJvdykge1xuICAgICAgICAgIC8vIHRoZSBwb3NpdGlvbiB3YXMgc2hpZnRlZCBkb3duIGEgbnVtYmVyIG9mIGxpbmVzXG4gICAgICAgICAgcmV0dXJuIHsgcm93OiByb3cgKyByb3dEZWx0YSwgY29sdW1uIH07XG4gICAgICAgIH0gZWxzZSBpZiAocm93ID09PSBzdGFydC5yb3cgJiYgY29sdW1uID4gc3RhcnQuY29sdW1uKSB7XG4gICAgICAgICAgaWYgKHJvd0RlbHRhID4gMCkge1xuICAgICAgICAgICAgLy8gdGhlIHBvc2l0aW9uIHdhcyBzaGlmdGVkIHRvIGEgbmV3IGxpbmUsXG4gICAgICAgICAgICAvLyBzaGlmdCBsZWZ0IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyByZW1haW5pbmcgb24gdGhlIG9sZCBsaW5lXG4gICAgICAgICAgICByZXR1cm4geyByb3c6IHJvdyArIHJvd0RlbHRhLCBjb2x1bW46IGNvbHVtbiAtIHN0YXJ0LmNvbHVtbiB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGUgcG9zaXRpb24gd2FzIHNoaWZ0ZWQgd2l0aGluIHRoZSBsaW5lXG4gICAgICAgICAgICByZXR1cm4geyByb3csIGNvbHVtbjogY29sdW1uICsgY29sdW1uRGVsdGEgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlIHBvc2l0aW9uIHdhcyBub3Qgc2hpZnRlZFxuICAgICAgICAgIHJldHVybiB7IHJvdywgY29sdW1uIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcE9iamVjdChzdGF0ZSwgbWFwUmVtb3RlQ3Vyc29yKG1hcFBvc2l0aW9uKSk7XG4gICAgfVxuICAgIGNhc2UgJ0RFTEVURSc6IHtcbiAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gYWN0aW9uO1xuXG4gICAgICBjb25zdCByb3dEZWx0YSA9IGVuZC5yb3cgLSBzdGFydC5yb3c7XG4gICAgICBjb25zdCBjb2x1bW5EZWx0YSA9IHJvd0RlbHRhID09PSAwID8gZW5kLmNvbHVtbiAtIHN0YXJ0LmNvbHVtbiA6IGVuZC5jb2x1bW47XG5cbiAgICAgIGZ1bmN0aW9uIG1hcFBvc2l0aW9uKHsgcm93LCBjb2x1bW4gfTogQWNlUG9zaXRpb24pOiBBY2VQb3NpdGlvbiB7XG4gICAgICAgIGlmIChyb3cgPiBlbmQucm93KSB7XG4gICAgICAgICAgLy8gdGhlIHBvc2l0aW9uIHdhcyBzaGlmdGVkIHVwIGEgbnVtYmVyIG9mIGxpbmVzXG4gICAgICAgICAgcmV0dXJuIHsgcm93OiByb3cgLSByb3dEZWx0YSwgY29sdW1uIH07XG4gICAgICAgIH0gZWxzZSBpZiAocm93ID09PSBlbmQucm93ICYmIGNvbHVtbiA+IGVuZC5jb2x1bW4pIHtcbiAgICAgICAgICBpZiAocm93RGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAvLyB0aGUgcG9zaXRpb24gd2FzIHNoaWZ0ZWQgdG8gYSBuZXcgbGluZSxcbiAgICAgICAgICAgIC8vIHNoaWZ0IHJpZ2h0IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyByZW1haW5pbmcgb24gdGhlIG5ldyBsaW5lXG4gICAgICAgICAgICByZXR1cm4geyByb3c6IHJvdyAtIHJvd0RlbHRhLCBjb2x1bW46IGNvbHVtbiArIHN0YXJ0LmNvbHVtbiB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGUgcG9zaXRpb24gd2FzIHNoaWZ0ZWQgd2l0aGluIHRoZSBsaW5lXG4gICAgICAgICAgICByZXR1cm4geyByb3csIGNvbHVtbjogY29sdW1uIC0gY29sdW1uRGVsdGEgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlIHBvc2l0aW9uIHdhcyBub3Qgc2hpZnRlZFxuICAgICAgICAgIHJldHVybiB7IHJvdywgY29sdW1uIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcE9iamVjdChzdGF0ZSwgbWFwUmVtb3RlQ3Vyc29yKG1hcFBvc2l0aW9uKSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICAgICAgdGhyb3cgJ3VucmVhY2hhYmxlJztcbiAgfVxufVxuXG50eXBlIFJlbW90ZUN1cnNvcnNIb29rID0ge3xcbiAgZGlzcGF0Y2goYWN0aW9uOiBSZW1vdGVDdXJzb3JzQWN0aW9uKTogdm9pZCxcbiAgZ2V0QWNlTWFya2VycygpOiBBY2VNYXJrZXJbXSxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VSZW1vdGVDdXJzb3JzKFxuICBnZXRDbGFzc05hbWU6IChzaXRlSWQ6IHN0cmluZywgdHlwZTogJ3NlbGVjdGlvbicgfCAnY3Vyc29yJykgPT4gc3RyaW5nLFxuKTogUmVtb3RlQ3Vyc29yc0hvb2sge1xuICBjb25zdCBbY3Vyc29ycywgZGlzcGF0Y2hdID0gUmVhY3QudXNlUmVkdWNlcjxSZW1vdGVDdXJzb3JzLCBSZW1vdGVDdXJzb3JzQWN0aW9uPihcbiAgICByZW1vdGVDdXJzb3JzUmVkdWNlcixcbiAgICB7XG4gICAgICBmb286IHtcbiAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgc3RhcnQ6IHsgcm93OiAwLCBjb2x1bW46IDEgfSxcbiAgICAgICAgICBlbmQ6IHsgcm93OiAwLCBjb2x1bW46IDMgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3Vyc29yOiB7IHJvdzogMCwgY29sdW1uOiAzIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBkaXNwYXRjaCxcbiAgICBnZXRBY2VNYXJrZXJzKCkge1xuICAgICAgY29uc3QgbWFya2VycyA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IFtzaXRlSWQsIHJlbW90ZUN1cnNvcl0gb2YgT2JqZWN0LmVudHJpZXMoY3Vyc29ycykpIHtcbiAgICAgICAgLy8gJEZsb3dFeHBlY3RFcnJvclxuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgY3Vyc29yIH06IFJlbW90ZUN1cnNvciA9IHJlbW90ZUN1cnNvcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgbWFya2Vycy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0Um93OiBzZWxlY3Rpb24uc3RhcnQucm93LFxuICAgICAgICAgICAgc3RhcnRDb2w6IHNlbGVjdGlvbi5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgICBlbmRSb3c6IHNlbGVjdGlvbi5lbmQucm93LFxuICAgICAgICAgICAgZW5kQ29sOiBzZWxlY3Rpb24uZW5kLmNvbHVtbixcbiAgICAgICAgICAgIGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lKHNpdGVJZCwgJ3NlbGVjdGlvbicpLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJzb3IgIT09IG51bGwpIHtcbiAgICAgICAgICBtYXJrZXJzLnB1c2goe1xuICAgICAgICAgICAgc3RhcnRSb3c6IGN1cnNvci5yb3csXG4gICAgICAgICAgICBzdGFydENvbDogY3Vyc29yLmNvbHVtbixcbiAgICAgICAgICAgIGVuZFJvdzogY3Vyc29yLnJvdyxcbiAgICAgICAgICAgIGVuZENvbDogY3Vyc29yLmNvbHVtbiArIDEsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGdldENsYXNzTmFtZShzaXRlSWQsICdjdXJzb3InKSxcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya2VycztcbiAgICB9LFxuICB9O1xufVxuIiwiLy8gQGZsb3dcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnQgKi9cblxuLy8gdGFrZXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2sgYChlcnIsIHJlc3VsdCkgPT4gLi4uYFxuLy8gYXMgaXRzIGxhc3QgcGFyYW1ldGVyIGFuZCBtYWtlcyBpdCBpbnRvIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZSBpbnN0ZWFkXG4vLyBGbG93IGRvZXNuJ3QgbWFuYWdlIHRvIGNhcHR1cmUgdGhlIHR5cGUgb2YgYCguLi5hcmdzLCBjYikgPT4gdm9pZGAgdW5mb3J0dW5hdGVseSxcbi8vIHNvIHRoZSBhY3R1YWwgdHlwZSBvZiB0aGUgcHJvbWlzZSBjYW4gbm90IGJlIGluZmVycmVkLCBhbmQgYXJndW1lbnQgdHlwZXMgYXJlIG5vdCBjaGVja2VkLlxuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2lmeTxUPihmbjogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKTogKC4uLmFyZ3M6IGFueVtdKSA9PiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZuKC4uLmFyZ3MsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZWplY3QoZXJyKTtcbiAgICAgICAgZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcE9iamVjdDxULCBVPihcbiAgb2JqOiB7fCBba2V5OiBzdHJpbmddOiBUIHx9LFxuICBmbjogKHZhbHVlOiBULCBrZXk6IHN0cmluZykgPT4gVSxcbik6IHt8IFtrZXk6IHN0cmluZ106IFUgfH0ge1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob2JqKTtcbiAgY29uc3QgbmV3RW50cmllcyA9IGVudHJpZXMubWFwKChba2V5LCB2YWx1ZTBdKSA9PiB7XG4gICAgLy8gJEZsb3dFeHBlY3RFcnJvclxuICAgIGNvbnN0IHZhbHVlOiBUID0gdmFsdWUwO1xuICAgIHJldHVybiBba2V5LCBmbih2YWx1ZSwga2V5KV07XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKG5ld0VudHJpZXMpO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQVVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUhBLGFBS0E7QUFDQTtBQVNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFLQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBZEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF5QkE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFFQTtBQUNBO0FBQ0E7QUE4QkE7QUFTQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlRQTtBQUNBO0FBK1FBOzs7Ozs7OztBQ3BUQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakNBO0FBQ0E7QUFrQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWlCQTtBQVlBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBek5BO0FBQ0E7QUEwTkE7Ozs7Ozs7O0FDdFBBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwY0E7QUFDQTtBQXFjQTs7Ozs7Ozs7QUMzY0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQUNBO0FBc0JBOzs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQTlCQTtBQUNBO0FBK0JBOzs7Ozs7Ozs7Ozs7QUN4Q0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQXJEQTtBQUNBO0FBc0RBOzs7Ozs7OztBQzVEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQW1CQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFJQTtBQUdBO0FBRkE7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBTEE7QUFIQTtBQVdBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFqQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQVhBO0FBWUE7Ozs7Ozs7O0FDOUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBUUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7QUF6QkE7QUEwQkE7Ozs7Ozs7O0FDakRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQXBFQTtBQXNFQTtBQUNBO0FBTUE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUxBO0FBREE7QUFXQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQ0E7QUFrQ0E7Ozs7Ozs7O0FDcktBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBIiwic291cmNlUm9vdCI6IiJ9